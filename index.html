<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ludo 3D - Championship Edition</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Outfit:wght@300;500;700;900&display=swap');
        
        :root {
            /* NIGHT THEME (Default) */
            --bg-color: #0f0c29;
            --text-color: #ffffff;
            --glass-bg: rgba(15, 23, 42, 0.75);
            --glass-border: rgba(255, 255, 255, 0.15);
            --shadow-color: rgba(0,0,0,0.5);
            
            --red: #ff4757; --green: #2ed573; --yellow: #ffa502; --blue: #1e90ff;
        }

        /* DAY THEME */
        body.day-mode {
            --bg-color: #87CEEB;
            --text-color: #1e293b;
            --glass-bg: rgba(255, 255, 255, 0.65);
            --glass-border: rgba(255, 255, 255, 0.6);
            --shadow-color: rgba(0,0,0,0.2);
        }

        * { margin:0; padding:0; box-sizing:border-box; user-select:none; -webkit-tap-highlight-color:transparent; font-family:'Outfit', sans-serif; }
        
        body { 
            overflow:hidden; background: var(--bg-color); color: var(--text-color);
            height: 100vh; width: 100vw; transition: background 1s ease, color 0.5s ease;
        }

        #gameCanvas { position: fixed; top: 0; left: 0; z-index: 1; outline: none; }

        /* UI LAYER */
        #ui-layer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
            transition: opacity 0.5s;
        }

        .glass-panel {
            background: var(--glass-bg);
            backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--glass-border);
            box-shadow: 0 8px 32px 0 var(--shadow-color);
            border-radius: 16px; pointer-events: auto;
            transition: background 0.5s, border-color 0.5s;
        }

        /* HUD */
        #minimap-container {
            position: absolute; top: 15px; left: 15px;
            width: 90px; height: 90px; padding: 5px;
            display: flex; flex-direction: column; align-items: center;
            z-index: 30; padding-top: max(5px, env(safe-area-inset-top));
        }
        #minimap-canvas { width: 100%; height: 100%; border-radius: 8px; opacity: 0.9; }
        
        #stats-panel {
            position: absolute; top: 120px; left: 15px;
            width: 110px; padding: 10px; display: none;
            flex-direction: column; gap: 5px; font-size: 0.8rem; z-index: 19;
        }
        .stat-row { display: flex; justify-content: space-between; }
        .stat-val { font-weight: 700; color: #ffd700; }
        body.day-mode .stat-val { color: #d35400; }

        #theme-fab {
            position: absolute; top: 15px; right: 15px;
            width: 45px; height: 45px; border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            font-size: 1.2rem; cursor: pointer; z-index: 30;
            padding-top: max(0px, env(safe-area-inset-top));
            transition: transform 0.3s;
        }
        #theme-fab:active { transform: scale(0.9); }

        .badges-container { 
            display: flex; gap: 6px; position: absolute; top: 20px; left: 50%; 
            transform: translateX(-50%); z-index: 15;
            padding-top: env(safe-area-inset-top);
            transition: top 0.3s;
        }
        .player-badge {
            display: flex; flex-direction: column; align-items: center;
            padding: 6px 8px; background: rgba(0,0,0,0.6); border-radius: 10px;
            transition: all 0.3s; border: 2px solid transparent; min-width: 45px;
        }
        body.day-mode .player-badge { background: rgba(255,255,255,0.7); box-shadow: 0 4px 10px rgba(0,0,0,0.1); }
        .player-badge.active { transform: scale(1.15); box-shadow: 0 0 15px rgba(255,255,255,0.2); background: rgba(255,255,255,0.15); }
        body.day-mode .player-badge.active { background: white; border-width: 2px; }
        .player-badge.active[data-p="0"] { border-color: var(--red); }
        .player-badge.active[data-p="1"] { border-color: var(--green); }
        .player-badge.active[data-p="2"] { border-color: var(--yellow); }
        .player-badge.active[data-p="3"] { border-color: var(--blue); }
        
        .p-icon { font-size: 1rem; margin-bottom: 2px; }
        .p-name { font-size: 0.6rem; font-weight: 700; text-transform: uppercase; margin-bottom: 2px; }
        .p-dots { display: flex; gap: 2px; }
        .dot { width: 5px; height: 5px; border-radius: 50%; background: #444; }
        .dot.home { background: #ffd700; box-shadow: 0 0 4px #ffd700; }
        body.day-mode .dot.home { background: #f1c40f; box-shadow: none; }

        /* SETTINGS */
        #settings-btn {
            position: absolute; bottom: 30px; right: 20px;
            width: 45px; height: 45px; border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            font-size: 1.2rem; cursor: pointer; z-index: 60;
            padding-bottom: env(safe-area-inset-bottom);
        }
        #settings-menu {
            position: absolute; bottom: 90px; right: 20px;
            width: 200px; padding: 15px; display: flex; flex-direction: column; gap: 12px;
            transform: scale(0); transform-origin: bottom right; transition: transform 0.3s ease;
            z-index: 59;
        }
        #settings-menu.open { transform: scale(1); }
        .setting-row { display: flex; justify-content: space-between; align-items: center; font-size: 0.9rem; font-weight: 600; }
        .toggle-switch {
            width: 40px; height: 20px; background: rgba(255,255,255,0.2);
            border-radius: 20px; position: relative; cursor: pointer; border: 1px solid rgba(255,255,255,0.1);
        }
        body.day-mode .toggle-switch { background: rgba(0,0,0,0.1); border-color: rgba(0,0,0,0.1); }
        .toggle-knob {
            width: 16px; height: 16px; background: white; border-radius: 50%;
            position: absolute; top: 1px; left: 2px; transition: 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .toggle-switch.on { background: var(--green); }
        .toggle-switch.on .toggle-knob { left: 20px; }
        .btn-restart {
            background: var(--red); color: white; border: none; padding: 10px; border-radius: 8px;
            font-weight: 700; cursor: pointer; margin-top: 5px; width: 100%;
        }

        /* --- THREE.JS DICE CONTAINER --- */
        #dice-box {
            position: absolute;
            bottom: 20px; 
            left: 50%; transform: translateX(-50%);
            width: 120px; height: 120px;
            z-index: 50; 
            pointer-events: auto;
            cursor: pointer;
            padding-bottom: env(safe-area-inset-bottom);
        }
        #diceCanvas { width: 100%; height: 100%; display: block; }

        /* STATUS TEXT */
        #status-text {
            position: absolute; 
            bottom: 140px; 
            left: 50%; transform: translateX(-50%);
            padding: 8px 25px; border-radius: 50px;
            font-weight: 800; font-size: 1rem; letter-spacing: 1px;
            text-align: center; white-space: nowrap; opacity: 0; transition: opacity 0.3s;
            border: 1px solid var(--glass-border); text-shadow: 0 2px 4px var(--shadow-color);
            color: var(--text-color);
            z-index: 10; margin-bottom: env(safe-area-inset-bottom);
        }
        #status-text.show { opacity: 1; }

        /* SCREENS */
        #landing-screen {
            position: fixed; top:0; left:0; width:100%; height:100%;
            background: rgba(10, 5, 30, 0.4); 
            backdrop-filter: blur(5px);
            z-index: 100; display: flex; justify-content: center; align-items: center; transition: opacity 0.5s;
        }
        #name-modal { 
            position: fixed; top:0; left:0; width:100%; height:100%;
            background: rgba(0,0,0,0.85); z-index: 101; display: none; 
            justify-content: center; align-items: center; backdrop-filter: blur(5px);
        }
        
        .welcome-card { 
            text-align: center; padding: 40px; max-width: 450px; width: 85%;
            animation: float 6s ease-in-out infinite; 
            background: rgba(15, 23, 42, 0.75); border: 1px solid rgba(255,255,255,0.2);
            border-radius: 20px; backdrop-filter: blur(10px);
            overflow-y: auto; max-height: 90vh;
        }
        @keyframes float { 0%,100%{transform:translateY(0);} 50%{transform:translateY(-10px);} }
        .game-title { 
            font-size: 3.5rem; font-weight: 900; margin-bottom: 10px; line-height: 1;
            background: linear-gradient(135deg, #fff, #a5b4fc); -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 15px rgba(108, 99, 255, 0.5));
        }
        body.day-mode .game-title { background: linear-gradient(135deg, #6C63FF, #4834d4); -webkit-background-clip: text; }

        .btn-start, .btn-secondary {
            color: white; border: none; padding: 16px; width: 100%;
            font-size: 1.1rem; font-weight: 800; border-radius: 50px;
            cursor: pointer; margin-top: 10px; transition: transform 0.2s;
        }
        .btn-start { background: linear-gradient(135deg, #6C63FF, #4834d4); box-shadow: 0 0 25px rgba(108, 99, 255, 0.5); }
        .btn-secondary { background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); }
        body.day-mode .btn-secondary { background: rgba(0,0,0,0.05); border-color: rgba(0,0,0,0.1); color: #333; }
        .btn-start:active, .btn-secondary:active { transform: scale(0.95); }

        .input-field {
            background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.2);
            color: white; padding: 15px; border-radius: 12px; width: 100%;
            font-size: 1.1rem; margin-bottom: 15px; text-align: center; font-weight: 700;
        }
        .input-field:focus { outline: none; border-color: var(--red); background: rgba(0,0,0,0.3); }

        .modal-overlay {
            position: fixed; top:0; left:0; width:100%; height:100%;
            background: rgba(0,0,0,0.85); z-index: 200; display: none; justify-content: center; align-items: center; backdrop-filter: blur(5px);
        }
        body.day-mode .modal-overlay { background: rgba(255,255,255,0.8); }
        .modal-content { width: 85%; max-width: 400px; padding: 30px; text-align: left; }
        .modal-title { font-size: 1.5rem; margin-bottom: 15px; color: #ffd700; display:flex; align-items:center; gap:10px;}
        body.day-mode .modal-title { color: #d35400; }
        .rule-item { margin-bottom: 12px; font-size: 0.95rem; line-height: 1.4; display:flex; gap:10px; }
        .rule-icon { color: #6C63FF; width: 20px; }
        
        @media (max-width: 600px) {
            .game-title { font-size: 2.8rem; }
            #stats-panel { top: 110px; }
            .badges-container { top: 90px; } 
            #minimap-container { width: 80px; height: 80px; }
            
            /* PUSH TO ABSOLUTE BOTTOM */
            #dice-box { bottom: 10px; } 
            #status-text { bottom: 120px; }
        }
    </style>
</head>
<body onclick="startAudioEngine()">

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer" style="opacity: 0;"> 
        <div id="minimap-container" class="glass-panel">
            <canvas id="minimap-canvas" width="100" height="100"></canvas>
        </div>

        <div id="stats-panel" class="glass-panel">
            <div style="font-size:0.7rem; opacity:0.7; margin-bottom:5px;">LIVE STATS</div>
            <div class="stat-row"><span>MOVES:</span> <span class="stat-val" id="stat-moves">0</span></div>
            <div class="stat-row"><span>KILLS:</span> <span class="stat-val" id="stat-kills">0</span></div>
        </div>

        <div id="theme-fab" class="glass-panel" onclick="toggleTheme(this)">
            <i class="fas fa-moon" id="theme-icon"></i>
        </div>

        <div class="badges-container">
            <div class="player-badge active" id="p0" data-p="0"><i class="fas fa-user p-icon" style="color:var(--red)"></i><span class="p-name" id="p0-name">YOU</span><div class="p-dots" id="dots0"></div></div>
            <div class="player-badge" id="p1" data-p="1"><i class="fas fa-robot p-icon" style="color:var(--green)"></i><span class="p-name">CPU</span><div class="p-dots" id="dots1"></div></div>
            <div class="player-badge" id="p2" data-p="2"><i class="fas fa-robot p-icon" style="color:var(--yellow)"></i><span class="p-name">CPU</span><div class="p-dots" id="dots2"></div></div>
            <div class="player-badge" id="p3" data-p="3"><i class="fas fa-robot p-icon" style="color:var(--blue)"></i><span class="p-name">CPU</span><div class="p-dots" id="dots3"></div></div>
        </div>

        <div id="status-text" class="glass-panel">YOUR TURN</div>

        <div id="settings-btn" class="glass-panel" onclick="toggleSettingsMenu()">
            <i class="fas fa-cog"></i>
        </div>
        <div id="settings-menu" class="glass-panel">
            <div class="setting-row">
                <span>Minimap</span>
                <div class="toggle-switch on" onclick="toggleSwitch('map', this)"><div class="toggle-knob"></div></div>
            </div>
            <div class="setting-row">
                <span>Stats</span>
                <div class="toggle-switch" onclick="toggleSwitch('stats', this)"><div class="toggle-knob"></div></div>
            </div>
            <div class="setting-row">
                <span>Sound</span>
                <div class="toggle-switch on" onclick="toggleSwitch('sound', this)"><div class="toggle-knob"></div></div>
            </div>
             <div class="setting-row">
                <span>Music</span>
                <div class="toggle-switch on" onclick="toggleSwitch('music', this)"><div class="toggle-knob"></div></div>
            </div>
            <div class="setting-row">
                <span>Day Mode</span>
                <div class="toggle-switch" id="day-switch" onclick="toggleTheme(this)"><div class="toggle-knob"></div></div>
            </div>
            <button class="btn-restart" onclick="if(confirm('Restart Game?')) location.reload()"><i class="fas fa-redo"></i> NEW GAME</button>
        </div>

        <div id="dice-box" onclick="handleDiceClick()">
            <canvas id="diceCanvas"></canvas>
        </div>
    </div>

    <div id="landing-screen">
        <div class="welcome-card glass-panel">
            <h1 class="game-title">LUDO 3D</h1>
            <p style="margin-bottom:20px; opacity:0.8; font-weight:500; letter-spacing:1px;">CONTEST EDITION</p>
            <button class="btn-start" id="startBtn">PLAY GAME</button>
            <button class="btn-secondary" onclick="openRules()">HOW TO PLAY</button>
            
            <div class="about-text" style="margin-top: 25px; border-top: 1px solid rgba(255,255,255,0.2); padding-top: 15px; font-size: 0.85rem; opacity: 0.9; line-height: 1.5; color: #ddd;">
                <p>Developed by <strong style="color:white;">Babatunde Oremakinde</strong><br>for Nairaland 3D Ludo contest</p>
            </div>
            <p style="margin-top:10px; font-size:12px; opacity:0.6; color:white;">Tap anywhere to enable sound</p>
        </div>
    </div>

    <div id="name-modal">
        <div class="welcome-card glass-panel">
            <h2 class="modal-title" style="margin-bottom:10px;">Who is playing?</h2>
            <input type="text" id="player-name-input" class="input-field" placeholder="Player Name" maxlength="8">
            <button class="btn-start" onclick="confirmName()">START</button>
        </div>
    </div>

    <div id="rules-modal" class="modal-overlay">
        <div class="modal-content glass-panel">
            <div class="modal-title"><i class="fas fa-book"></i> Rules</div>
            <div class="rule-item"><i class="fas fa-dice-one rule-icon"></i> <span>Roll a <strong>6</strong> to leave your base.</span></div>
            <div class="rule-item"><i class="fas fa-star rule-icon"></i> <span><strong>Star</strong> spaces are safe zones.</span></div>
            <div class="rule-item"><i class="fas fa-skull rule-icon"></i> <span>Land on enemies to <strong>capture</strong> them.</span></div>
            <div class="rule-item"><i class="fas fa-trophy rule-icon"></i> <span>Get all 4 pieces to center to <strong>win</strong>.</span></div>
            <button class="btn-start" onclick="closeRules()">GOT IT</button>
        </div>
    </div>

    <div id="win-modal" class="modal-overlay">
        <div class="modal-content glass-panel" style="text-align:center;">
            <i class="fas fa-trophy" style="font-size:5rem; color:#ffd700; margin-bottom:20px;"></i>
            <h1 class="game-title" id="winner-name" style="font-size:2.5rem;">RED WINS!</h1>
            <button class="btn-start" onclick="location.reload()">PLAY AGAIN</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <script>
        // CONFIG
        const COLORS = [0xff4757, 0x2ed573, 0xffa502, 0x1e90ff];
        const HEX_STRINGS = ['#ff4757', '#2ed573', '#ffa502', '#1e90ff'];
        const NAMES = ['YOU', 'GREEN', 'YELLOW', 'BLUE'];
        const BOARD_SIZE = 15;
        const CELL_SIZE = 1; 
        
        let scene, camera, renderer, raycaster, mouse;
        let board = [], pieces = [], stars, clouds, sun;
        let ambientLight, sunLight;
        let currentPlayer = 0, diceValue = 1, gameState = 'MENU';
        let validMoves = [], glowingPieces = [];
        let diceScene, diceCamera, diceRenderer, diceMesh;
        let diceRotX = 0, diceRotY = 0, diceRotZ = 0;
        let soundEnabled = true, musicEnabled = true, dayMode = false;
        let orbitAngle = 0;
        let gameStats = { moves: 0, kills: 0 };
        let introInterval;
        let musicInterval;
        
        const AudioCtx = window.AudioContext || window.webkitAudioContext;
        let ctx;

        function startAudioEngine() {
            if(!ctx) { ctx = new AudioCtx(); playIntroMusic(); }
            if(ctx.state === 'suspended') { ctx.resume().then(() => playIntroMusic()); }
        }

        function playIntroMusic() {
            if(musicInterval) return;
            let noteIdx = 0;
            const introNotes = [261.63, 329.63, 392.00, 493.88]; 
            musicInterval = setInterval(() => {
                if(!musicEnabled || !ctx) return;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.frequency.setValueAtTime(introNotes[noteIdx % 4], ctx.currentTime);
                osc.type = 'triangle';
                gain.gain.setValueAtTime(0.05, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 1.5);
                osc.connect(gain); gain.connect(ctx.destination);
                osc.start(); osc.stop(ctx.currentTime + 1.5);
                noteIdx++;
            }, 500); 
        }

        const sfx = {
            roll: () => { 
                if(!soundEnabled || !ctx) return;
                const bufferSize = ctx.sampleRate * 0.3;
                const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                const noise = ctx.createBufferSource();
                noise.buffer = buffer;
                const gain = ctx.createGain();
                gain.gain.setValueAtTime(0.3, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);
                noise.connect(gain); gain.connect(ctx.destination);
                noise.start();
            },
            move: () => {
                if(!soundEnabled || !ctx) return;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.frequency.setValueAtTime(400, ctx.currentTime);
                osc.frequency.linearRampToValueAtTime(600, ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.2, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);
                osc.connect(gain); gain.connect(ctx.destination);
                osc.start(); osc.stop(ctx.currentTime + 0.1);
            },
            kill: () => {
                if(!soundEnabled || !ctx) return;
                const osc = ctx.createOscillator();
                osc.type = 'sawtooth';
                const gain = ctx.createGain();
                osc.frequency.setValueAtTime(150, ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(50, ctx.currentTime + 0.2);
                gain.gain.setValueAtTime(0.4, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.2);
                osc.connect(gain); gain.connect(ctx.destination);
                osc.start(); osc.stop(ctx.currentTime + 0.2);
            },
            win: () => {
                if(!soundEnabled || !ctx) return;
                [523, 659, 784, 1047, 523, 659, 784, 1047].forEach((f, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(f, ctx.currentTime + i*0.1);
                    gain.gain.setValueAtTime(0.1, ctx.currentTime + i*0.1);
                    gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + i*0.1 + 0.3);
                    osc.connect(gain); gain.connect(ctx.destination);
                    osc.start(ctx.currentTime + i*0.1); osc.stop(ctx.currentTime + i*0.1 + 0.3);
                });
            }
        };

        const getPath = (pid) => {
            const perimeter = [
                {x:6,y:13},{x:6,y:12},{x:6,y:11},{x:6,y:10},{x:6,y:9}, {x:5,y:8},{x:4,y:8},{x:3,y:8},{x:2,y:8},{x:1,y:8},{x:0,y:8},
                {x:0,y:7},{x:0,y:6},{x:1,y:6},{x:2,y:6},{x:3,y:6},{x:4,y:6},{x:5,y:6}, {x:6,y:5},{x:6,y:4},{x:6,y:3},{x:6,y:2},{x:6,y:1},{x:6,y:0},
                {x:7,y:0},{x:8,y:0},{x:8,y:1},{x:8,y:2},{x:8,y:3},{x:8,y:4},{x:8,y:5}, {x:9,y:6},{x:10,y:6},{x:11,y:6},{x:12,y:6},{x:13,y:6},{x:14,y:6},
                {x:14,y:7},{x:14,y:8},{x:13,y:8},{x:12,y:8},{x:11,y:8},{x:10,y:8},{x:9,y:8}, {x:8,y:9},{x:8,y:10},{x:8,y:11},{x:8,y:12},{x:8,y:13},{x:8,y:14},
                {x:7,y:14},{x:6,y:14} 
            ];
            const offset = pid * 13;
            let path = [];
            for(let i=0; i<51; i++) path.push(perimeter[(i + offset) % 52]);
            if(pid===0) path.push({x:7,y:13},{x:7,y:12},{x:7,y:11},{x:7,y:10},{x:7,y:9},{x:7,y:8});
            if(pid===1) path.push({x:1,y:7},{x:2,y:7},{x:3,y:7},{x:4,y:7},{x:5,y:7},{x:6,y:7});
            if(pid===2) path.push({x:7,y:1},{x:7,y:2},{x:7,y:3},{x:7,y:4},{x:7,y:5},{x:7,y:6});
            if(pid===3) path.push({x:13,y:7},{x:12,y:7},{x:11,y:7},{x:10,y:7},{x:9,y:7},{x:8,y:7});
            return path;
        };
        const PATHS = [getPath(0), getPath(1), getPath(2), getPath(3)];
        const YARDS = [
            [{x:1,y:13}, {x:4,y:13}, {x:1,y:10}, {x:4,y:10}], 
            [{x:1,y:1}, {x:4,y:1}, {x:1,y:4}, {x:4,y:4}],     
            [{x:13,y:1}, {x:10,y:1}, {x:13,y:4}, {x:10,y:4}], 
            [{x:13,y:13}, {x:10,y:13}, {x:13,y:10}, {x:10,y:10}] 
        ];
        const safePos = [[6,2],[2,6],[1,8],[6,12],[8,13],[12,8],[13,6],[8,1]];
        const startPos = {
            0: [[1,10],[1,13],[4,10],[4,13]],  // Red
            1: [[1,1],[1,4],[4,1],[4,4]],      // Green
            2: [[10,1],[10,4],[13,1],[13,4]],  // Yellow
            3: [[10,10],[10,13],[13,10],[13,13]] // Blue
        };

        function init() {
            const cvs = document.getElementById('gameCanvas');
            renderer = new THREE.WebGLRenderer({ canvas: cvs, antialias: true, alpha: true });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x0f0c29, 0.002); // Reduced fog density to 0.002
            
            // CAMERA
            camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 100);
            camera.position.set(0, 30, 20); 
            camera.lookAt(0, 0, 0); 

            // DYNAMIC LIGHTS - Default Night Mode
            ambientLight = new THREE.AmbientLight(0xffffff, 0.7); // Balanced Night Intensity
            scene.add(ambientLight);
            
            sunLight = new THREE.DirectionalLight(0xffffff, 0.5); 
            sunLight.position.set(10, 20, 10);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 1024; sunLight.shadow.mapSize.height = 1024;
            scene.add(sunLight);

            createBoard();
            createPieces();
            createStars();
            createEnvironment(); 
            createDice(); 

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            window.addEventListener('resize', onResize);
            window.addEventListener('touchstart', onPieceClick, {passive: false});
            window.addEventListener('mousedown', onPieceClick);
            
            document.getElementById('startBtn').addEventListener('click', showNameInput);

            onResize(); 
            animate();
        }

        // --- SOLID DICE ---
        function createDice() {
            const canvas = document.getElementById('diceCanvas');
            const box = document.getElementById('dice-box');
            diceScene = new THREE.Scene();
            diceCamera = new THREE.PerspectiveCamera(45, box.clientWidth/box.clientHeight, 0.1, 100);
            diceCamera.position.z = 6; diceCamera.position.y = 2; diceCamera.lookAt(0,0,0);
            
            diceRenderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true, antialias: true });
            diceRenderer.setSize(box.clientWidth, box.clientHeight);
            
            const amb = new THREE.AmbientLight(0xffffff, 0.7); diceScene.add(amb);
            const dir = new THREE.DirectionalLight(0xffffff, 0.8); dir.position.set(5, 5, 5); diceScene.add(dir);

            const geometry = new THREE.BoxGeometry(1.5, 1.5, 1.5); 
            const materials = [];
            for (let i = 1; i <= 6; i++) {
                const cvs = document.createElement('canvas'); cvs.width = 128; cvs.height = 128;
                const ctx = cvs.getContext('2d');
                ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,128,128);
                ctx.strokeStyle = '#cccccc'; ctx.lineWidth = 5; ctx.strokeRect(0,0,128,128);
                ctx.fillStyle = '#000000'; drawDots(ctx, i);
                const tex = new THREE.CanvasTexture(cvs);
                materials.push(new THREE.MeshStandardMaterial({ map: tex }));
            }
            diceMesh = new THREE.Mesh(geometry, materials);
            diceScene.add(diceMesh);
            diceMesh.rotation.x = Math.PI/2; 
        }

        function drawDots(ctx, n) {
            const r = 12; const c = 64; const o = 35;
            const dot = (x,y) => { ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); };
            if(n%2===1) dot(c,c);
            if(n>1) { dot(c-o,c-o); dot(c+o,c+o); }
            if(n>3) { dot(c-o,c+o); dot(c+o,c-o); }
            if(n===6) { dot(c-o,c); dot(c+o,c); }
        }

        function createEnvironment() {
            const geo = new THREE.BufferGeometry();
            const pos = [];
            for(let i=0; i<800; i++) pos.push((Math.random()-0.5)*80, Math.random()*40, (Math.random()-0.5)*80);
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            const mat = new THREE.PointsMaterial({color:0xffffff, size:0.15, transparent:true, opacity:0.8});
            stars = new THREE.Points(geo, mat);
            scene.add(stars);

            clouds = new THREE.Group();
            const cloudGeo = new THREE.SphereGeometry(1.5, 7, 7);
            const cloudMat = new THREE.MeshBasicMaterial({color: 0xffffff, transparent: true, opacity: 0.9});
            for(let i=0; i<8; i++) {
                const c = new THREE.Group();
                for(let j=0; j<4; j++) {
                    const puff = new THREE.Mesh(cloudGeo, cloudMat);
                    puff.position.set(Math.random()*3, Math.random()*1.5, Math.random()*3);
                    puff.scale.setScalar(1 + Math.random()*0.5);
                    c.add(puff);
                }
                c.position.set((Math.random()-0.5)*50, 8 + Math.random()*5, (Math.random()-0.5)*40);
                clouds.add(c);
            }
            const sunGeo = new THREE.SphereGeometry(4, 16, 16);
            const sunMat = new THREE.MeshBasicMaterial({color: 0xffaa00});
            sun = new THREE.Mesh(sunGeo, sunMat);
            sun.position.set(-25, 20, -25);
        }

        function createBoard() {
            boardGroup = new THREE.Group();
            const base = new THREE.Mesh(new THREE.BoxGeometry(16, 0.5, 16), new THREE.MeshStandardMaterial({color: 0x1a1a1a}));
            base.position.y = -0.25; base.receiveShadow = true;
            base.position.set(0, -0.25, 0);
            boardGroup.add(base);

            const cellGeo = new THREE.BoxGeometry(0.95, 0.1, 0.95);
            // Default Grey-White (e0e0e0)
            const whiteMat = new THREE.MeshStandardMaterial({color: 0xe0e0e0, roughness: 0.7});
            
            const createCell = (x, y, color) => {
                const mesh = new THREE.Mesh(cellGeo, color ? new THREE.MeshStandardMaterial({color, roughness: 0.7}) : whiteMat);
                mesh.position.set(x - 7, 0.05, y - 7);
                mesh.receiveShadow = true;
                boardGroup.add(mesh);
            };

            for(let x=0; x<15; x++) {
                for(let y=0; y<15; y++) {
                    if(x<6 && y>=9) { createCell(x,y, COLORS[0]); continue; }
                    if(x<6 && y<6) { createCell(x,y, COLORS[1]); continue; }
                    if(x>=9 && y<6) { createCell(x,y, COLORS[2]); continue; }
                    if(x>=9 && y>=9) { createCell(x,y, COLORS[3]); continue; }
                    if(x>=6 && x<=8 && y>=6 && y<=8) {
                        if(!(x==7 && y==7)) createCell(x,y, 0xffd700);
                        continue;
                    }
                    let col = null;
                    if(x===7 && y>8 && y<14) col = COLORS[0];
                    if(y===7 && x>0 && x<6) col = COLORS[1];
                    if(x===7 && y>0 && y<6) col = COLORS[2];
                    if(y===7 && x>8 && x<14) col = COLORS[3];
                    if((x==6 && y==13) || (x==8 && y==1) || (x==1 && y==8) || (x==13 && y==6)) col = 0x888888;
                    if((x>=6 && x<=8) || (y>=6 && y<=8)) createCell(x,y, col);
                }
            }
            scene.add(boardGroup);
        }
        
        function getCellColor(x, z) {
            if (x >= 0 && x <= 5 && z >= 0 && z <= 5) return 0xff4444; 
            if (x >= 0 && x <= 5 && z >= 9 && z <= 14) return 0x44ff44; 
            if (x >= 9 && x <= 14 && z >= 9 && z <= 14) return 0xffff44; 
            if (x >= 9 && x <= 14 && z >= 0 && z <= 5) return 0x4444ff; 
            if (x === 7 || z === 7) return 0xe8e8e8;
            if ((x === 6 || x === 8) && (z >= 1 && z <= 13)) return 0xf0f0f0;
            if ((z === 6 || z === 8) && (x >= 1 && x <= 13)) return 0xf0f0f0;
            return 0xcccccc;
        }
        function isSafe(x, z) { return safePos.some(p => p[0] === x && p[1] === z); }

        function createPieces() {
            for (let player = 0; player < 4; player++) {
                pieces[player] = [];
                for (let i = 0; i < 4; i++) {
                    const points = [];
                    points.push(new THREE.Vector2(0,0)); 
                    points.push(new THREE.Vector2(0.35,0));
                    points.push(new THREE.Vector2(0.35,0.2)); 
                    points.push(new THREE.Vector2(0.2,0.5));
                    points.push(new THREE.Vector2(0,0.6));
                    const geo = new THREE.LatheGeometry(points, 20);
                    
                    const mat = new THREE.MeshStandardMaterial({ color: COLORS[player], metalness: 0.3, roughness: 0.4 });
                    const piece = new THREE.Mesh(geo, mat);
                    const pos = startPos[player][i];
                    
                    piece.position.set(pos[0] * CELL_SIZE - 7, 0, pos[1] * CELL_SIZE - 7);
                    
                    piece.castShadow = true;
                    piece.userData = { player, index: i, step: -1, ring: null }; 
                    
                    const ringGeo = new THREE.TorusGeometry(0.45, 0.08, 16, 32);
                    const ringMat = new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0 });
                    const ring = new THREE.Mesh(ringGeo, ringMat);
                    ring.rotation.x = -Math.PI / 2; ring.position.y = 0.05;
                    piece.add(ring); piece.userData.ring = ring;
                    scene.add(piece); pieces[player][i] = piece;
                }
            }
        }

        function createStars() {
            const safes = [[6,13],[8,1],[1,8],[13,6],[8,12],[6,2],[2,6],[12,8]];
            safes.forEach(pos => {
                const star = new THREE.Mesh(new THREE.OctahedronGeometry(0.15), new THREE.MeshBasicMaterial({color: 0xffd700}));
                star.position.set(pos[0]*CELL_SIZE - 7, 0.2, pos[1]*CELL_SIZE - 7);
                scene.add(star);
                gsap.to(star.position, {y: 0.5, duration: 1, yoyo: true, repeat: -1});
                gsap.to(star.rotation, {y: Math.PI, duration: 2, repeat: -1, ease: "none"});
            });
        }

        // LOGIC
        function showNameInput() {
            document.getElementById('landing-screen').style.display = 'none';
            document.getElementById('name-modal').style.display = 'flex';
            startAudioEngine();
        }

        function confirmName() {
            const input = document.getElementById('player-name-input');
            let name = input.value.trim().toUpperCase();
            if(name === "") name = "YOU";
            NAMES[0] = name;
            
            document.getElementById('p0-name').textContent = name;
            document.getElementById('name-modal').style.display = 'none';
            document.getElementById('ui-layer').style.opacity = 1;
            gameState = 'TURN_START';
            currentPlayer = 0;
            startTurn();
        }

        function startTurn() {
            gameState = 'TURN_START';
            document.querySelectorAll('.player-badge').forEach(b => b.classList.remove('active'));
            document.getElementById(`p${currentPlayer}`).classList.add('active');
            
            const angles = [{x:0,z:20}, {x:-15,z:7}, {x:0,z:-15}, {x:15,z:7}];
            const view = angles[currentPlayer];
            
            let zoomY = (window.innerWidth < 768) ? 42 : 30; // Mobile: 42 (Zoomed In more)

            gsap.to(camera.position, {
                x: view.x, z: view.z, y: zoomY, duration: 1.5,
                ease: "power2.inOut",
                onUpdate: () => camera.lookAt(0,0,0)
            });

            if(currentPlayer === 0) {
                setStatus(`${NAMES[0]}'S TURN`);
            } else {
                setStatus(`${NAMES[currentPlayer]}...`);
                setTimeout(aiRoll, 1000);
            }
        }

        function handleDiceClick() {
            if(currentPlayer !== 0 || gameState !== 'TURN_START') return;
            performRoll();
        }

        function aiRoll() { performRoll(); }

        function performRoll() {
            gameState = 'ROLLING';
            sfx.roll();
            
            gsap.to(diceMesh.rotation, {
                x: `+=${Math.PI * 4 + Math.random()}`,
                y: `+=${Math.PI * 4 + Math.random()}`,
                duration: 0.6,
                ease: "power1.inOut"
            });
            gsap.to(diceMesh.position, {
                y: 1.5,
                duration: 0.3,
                yoyo: true,
                repeat: 1,
                ease: "power2.out",
                onComplete: finalizeRoll
            });
        }

        function finalizeRoll() {
            diceValue = Math.ceil(Math.random() * 6);
            let tx=0, ty=0;
            const r = Math.PI/2;
            switch(diceValue) {
                case 1: ty = -r; break;
                case 2: ty = r; break;
                case 3: tx = r; break;
                case 4: tx = -r; break;
                case 5: tx = 0; break;
                case 6: ty = Math.PI; break;
            }
            gsap.to(diceMesh.rotation, {
                x: tx, y: ty, z: 0,
                duration: 0.2,
                onComplete: checkValidMoves
            });
        }

        function checkValidMoves() {
            validMoves = [];
            pieces[currentPlayer].forEach(p => {
                if(p.userData.step >= PATHS[currentPlayer].length - 1) return;
                if(p.userData.step === -1) { if(diceValue === 6) validMoves.push(p); }
                else {
                    if(p.userData.step + diceValue < PATHS[currentPlayer].length) validMoves.push(p);
                }
            });

            if(validMoves.length === 0) {
                setStatus(`NO MOVES`); setTimeout(endTurn, 1000);
            } else {
                if(currentPlayer === 0) {
                    gameState = 'WAITING_INPUT'; setStatus(`TAP PIECE`); highlightPieces(true);
                    if(validMoves.length === 1 && validMoves[0].userData.step !== -1) movePiece(validMoves[0]);
                } else {
                    gameState = 'AI_THINKING'; setTimeout(aiDecide, 800);
                }
            }
        }

        function aiDecide() {
            let best = validMoves[0], maxScore = -100;
            validMoves.forEach(p => {
                let score = Math.random() * 10;
                if(p.userData.step === -1) score += 50; 
                else {
                    const dest = p.userData.step + diceValue;
                    if(dest >= PATHS[currentPlayer].length-1) score += 100; 
                    score += dest;
                }
                if(score > maxScore) { maxScore = score; best = p; }
            });
            movePiece(best);
        }

        // WALKING ANIMATION
        function movePiece(piece) {
            gameState = 'MOVING'; highlightPieces(false);
            if(currentPlayer === 0) { gameStats.moves++; if(document.getElementById('stat-moves')) document.getElementById('stat-moves').textContent = gameStats.moves; }
            
            let cur = piece.userData.step;
            let target = cur + diceValue;

            if(cur === -1) {
                let startTile = PATHS[currentPlayer][0];
                jumpPiece(piece, startTile.x, startTile.y, () => {
                    piece.userData.step = 0;
                    checkTurnEnd(true); 
                });
            } else {
                let stepsTaken = 0;
                function doStep() {
                    if (stepsTaken < diceValue) {
                        stepsTaken++;
                        let nextIndex = cur + stepsTaken;
                        if(nextIndex >= PATHS[currentPlayer].length) { 
                            piece.userData.step = PATHS[currentPlayer].length - 1;
                            handleLanding(piece);
                            return; 
                        }
                        
                        let nextTile = PATHS[currentPlayer][nextIndex];
                        jumpPiece(piece, nextTile.x, nextTile.y, () => {
                            if (stepsTaken < diceValue) {
                                doStep();
                            } else {
                                piece.userData.step = nextIndex;
                                handleLanding(piece);
                            }
                        });
                    }
                }
                doStep();
            }
        }

        function jumpPiece(piece, tx, ty, onComplete) {
            sfx.move();
            const tl = gsap.timeline({onComplete: onComplete});
            tl.to(piece.position, { x: tx * CELL_SIZE - 7, z: ty * CELL_SIZE - 7, duration: 0.2, ease: "linear" }, 0);
            tl.to(piece.position, { y: 1.5, duration: 0.1, yoyo: true, repeat: 1, ease: "power1.out" }, 0);
        }

        function handleLanding(piece) {
            if(piece.userData.step >= PATHS[currentPlayer].length - 1) {
                sfx.win(); updateBadgeDots(currentPlayer);
                if(pieces[currentPlayer].every(p => p.userData.step >= PATHS[currentPlayer].length - 1)) {
                    document.getElementById('winner-name').innerText = `${NAMES[currentPlayer]} WINS!`;
                    document.getElementById('win-modal').style.display = 'flex'; return;
                }
                checkTurnEnd(true); return;
            }
            const px = Math.round(piece.position.x + 7);
            const py = Math.round(piece.position.z + 7);
            const isSafe = (px==6&&py==13)||(px==8&&py==1)||(px==1&&py==8)||(px==13&&py==6)||(px==8&&py==12)||(px==6&&py==2)||(px==2&&py==6)||(px==12&&py==8);
            let captured = false;
            if(!isSafe) {
                for(let op=0; op<4; op++) {
                    if(op === currentPlayer) continue;
                    pieces[op].forEach(en => {
                        const ex = Math.round(en.position.x + 7);
                        const ey = Math.round(en.position.z + 7);
                        if(ex === px && ey === py && en.userData.step !== -1) {
                            captureAnim(en); captured = true;
                            if(currentPlayer === 0) { gameStats.kills++; updateStatsUI(); }
                        }
                    });
                }
            }
            if(captured) { setStatus("CAPTURE! BONUS!"); setTimeout(() => checkTurnEnd(true), 1000); }
            else checkTurnEnd(diceValue === 6);
        }

        function captureAnim(piece) {
            sfx.kill();
            piece.userData.step = -1;
            const h = YARDS[piece.userData.player][piece.userData.index];
            gsap.to(piece.position, {x: h.x * CELL_SIZE - 7, z: h.y * CELL_SIZE - 7, y: 5, duration: 0.6, ease: "back.in(1.7)", onComplete: ()=>piece.position.y=0});
        }

        function checkTurnEnd(bonus) {
            if(bonus) { gameState = 'TURN_START'; startTurn(); } else endTurn();
        }
        function endTurn() { currentPlayer = (currentPlayer + 1) % 4; startTurn(); }

        function getValidMoves(pid, roll) {
            return [];
        }
        function highlightPieces(on) {
            validMoves.forEach(p => {
                p.userData.ring.material.opacity = on ? 1 : 0;
                if(on) gsap.to(p.position, {y: 0.5, duration: 0.5, yoyo: true, repeat: -1, overwrite: true});
                else { gsap.killTweensOf(p.position); p.position.y = 0; }
            });
        }
        function updateBadgeDots(pid) {
            const el = document.getElementById(`dots${pid}`); if(!el) return; el.innerHTML = '';
            const c = pieces[pid].filter(p => p.userData.step >= PATHS[pid].length - 1).length;
            for(let i=0; i<4; i++) {
                const d = document.createElement('div'); d.className = 'dot' + (i<c ? ' home' : ''); el.appendChild(d);
            }
        }
        function updateStatsUI() {
            if(document.getElementById('stat-moves')) document.getElementById('stat-moves').textContent = gameStats.moves;
            if(document.getElementById('stat-kills')) document.getElementById('stat-kills').textContent = gameStats.kills;
        }
        function setStatus(text) {
            const el = document.getElementById('status-text'); el.textContent = text;
            el.style.borderColor = HEX_STRINGS[currentPlayer]; el.classList.add('show');
        }
        function drawMinimap() {
            const ctx = document.getElementById('minimap-canvas').getContext('2d');
            ctx.fillStyle = dayMode ? '#e0e7ff' : '#1a1a1a'; ctx.fillRect(0,0,100,100);
            pieces.forEach(row => row.forEach(p => {
                if(p.userData.step >= PATHS[p.userData.player].length-1) return;
                const x = ((p.position.x + 7)/14)*80 + 10;
                const y = ((p.position.z + 7)/14)*80 + 10;
                ctx.fillStyle = HEX_STRINGS[p.userData.player];
                ctx.beginPath(); ctx.arc(x,y,3,0,Math.PI*2); ctx.fill();
            }));
        }

        function toggleSettingsMenu() { document.getElementById('settings-menu').classList.toggle('open'); }
        function toggleSwitch(type, el) {
            el.classList.toggle('on'); const isOn = el.classList.contains('on');
            if(type === 'map') document.getElementById('minimap-container').style.display = isOn ? 'flex' : 'none';
            if(type === 'stats') document.getElementById('stats-panel').style.display = isOn ? 'flex' : 'none';
            if(type === 'sound') soundEnabled = isOn;
            if(type === 'music') toggleMusic();
        }
        function toggleTheme(el) {
            const fab = document.getElementById('theme-fab');
            const icon = document.getElementById('theme-icon');
            const switchEl = document.getElementById('day-switch');
            dayMode = !dayMode;
            
            // DYNAMIC LIGHTING ADJUSTMENT
            if(dayMode) {
                document.body.classList.add('day-mode');
                icon.className = 'fas fa-sun'; icon.style.color = '#f1c40f';
                if(switchEl) switchEl.classList.add('on');
                // LIGHTS FOR DAY
                ambientLight.intensity = 0.6; 
                sunLight.intensity = 0.6; // Reduced to prevent washout
                sunLight.position.set(-20, 50, -20);
                scene.fog = new THREE.FogExp2(0x87CEEB, 0.002);
                scene.remove(stars); scene.add(clouds); scene.add(sun);
            } else {
                document.body.classList.remove('day-mode');
                icon.className = 'fas fa-moon'; icon.style.color = '#ffffff';
                if(switchEl) switchEl.classList.remove('on');
                // LIGHTS FOR NIGHT
                ambientLight.intensity = 0.7; // Lowered from 1.3 to fix over-brightness
                sunLight.intensity = 0.4;
                sunLight.position.set(10, 20, 10);
                scene.fog = new THREE.FogExp2(0x0f0c29, 0.002);
                scene.add(stars); scene.remove(clouds); scene.remove(sun);
            }
        }
        function openRules() { document.getElementById('rules-modal').style.display = 'flex'; }
        function closeRules() { document.getElementById('rules-modal').style.display = 'none'; }
        function toggleMusic() {
            musicEnabled = !musicEnabled;
            if(!musicEnabled && musicInterval) { clearInterval(musicInterval); musicInterval = null; }
            else if(musicEnabled && !musicInterval) { playIntroMusic(); } // Fixed: call playIntroMusic
        }

        function onPieceClick(e) {
            if(gameState !== 'WAITING_INPUT' || currentPlayer !== 0) return;
            e.preventDefault();
            const cx = e.touches ? e.touches[0].clientX : e.clientX;
            const cy = e.touches ? e.touches[0].clientY : e.clientY;
            mouse.x = (cx / window.innerWidth) * 2 - 1; mouse.y = -(cy / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(pieces[0]);
            if(intersects.length > 0) {
                const p = intersects[0].object;
                if(validMoves.includes(p)) movePiece(p);
            }
        }
        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight);
            const box = document.getElementById('dice-box');
            if(diceRenderer) diceRenderer.setSize(box.clientWidth, box.clientHeight);
            
            // MOBILE ADJUSTMENT
            if (window.innerWidth < 768) {
                 camera.position.set(0, 42, 25); // Lower Y to ZOOM IN + Make Board Bigger
                 camera.lookAt(0, 0, 0); 
            } else {
                 camera.position.set(0, 30, 20);
                 camera.lookAt(0, 0, 0);
            }
        }
        function animate() {
            requestAnimationFrame(animate); 
            renderer.render(scene, camera); 
            
            if(diceRenderer && diceScene && diceCamera) {
                diceRenderer.render(diceScene, diceCamera);
            }
            drawMinimap();
            
            if(gameState === 'MENU') {
                orbitAngle += 0.003;
                camera.position.x = Math.sin(orbitAngle) * 25;
                camera.position.z = Math.cos(orbitAngle) * 25;
                camera.position.y = 25; camera.lookAt(0,0,0);
            }
            if(clouds) clouds.children.forEach(c => {
                c.position.x += 0.02;
                if(c.position.x > 30) c.position.x = -30;
                
                const dist = Math.abs(c.position.x);
                let targetOpacity = 0.9;
                if (dist < 12) targetOpacity = 0.15; 
                c.children.forEach(puff => {
                    puff.material.opacity += (targetOpacity - puff.material.opacity) * 0.05;
                });
            });
        }

        init();
    </script>
</body>
</html>
