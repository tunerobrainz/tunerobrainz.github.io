<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ludo 3D - Championship Edition</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Outfit:wght@300;500;700;900&display=swap');
        
        :root {
            /* NIGHT THEME (Default) */
            --bg-color: #0f0c29;
            --text-color: #ffffff;
            --glass-bg: rgba(15, 23, 42, 0.7);
            --glass-border: rgba(255, 255, 255, 0.15);
            --shadow-color: rgba(0,0,0,0.5);
            
            --red: #ff4757; --green: #2ed573; --yellow: #ffa502; --blue: #1e90ff;
        }

        /* DAY THEME */
        body.day-mode {
            --bg-color: #87CEEB;
            --text-color: #1e293b;
            --glass-bg: rgba(255, 255, 255, 0.6);
            --glass-border: rgba(255, 255, 255, 0.6);
            --shadow-color: rgba(0,0,0,0.2);
        }

        * { margin:0; padding:0; box-sizing:border-box; user-select:none; -webkit-tap-highlight-color:transparent; font-family:'Outfit', sans-serif; }
        
        body { 
            overflow:hidden; background: var(--bg-color); color: var(--text-color);
            height: 100vh; width: 100vw; transition: background 1s ease, color 0.5s ease;
        }

        /* CANVASES */
        #gameCanvas { position: fixed; top: 0; left: 0; z-index: 1; outline: none; }
        
        /* UI LAYER */
        #ui-layer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
            transition: opacity 0.5s;
        }

        .glass-panel {
            background: var(--glass-bg);
            backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--glass-border);
            box-shadow: 0 8px 32px 0 var(--shadow-color);
            border-radius: 16px; pointer-events: auto;
            transition: background 0.5s, border-color 0.5s;
        }

        /* HUD */
        #minimap-container {
            position: absolute; top: 15px; left: 15px;
            width: 90px; height: 90px; padding: 5px;
            display: flex; flex-direction: column; align-items: center;
            z-index: 30; padding-top: max(5px, env(safe-area-inset-top));
        }
        #minimap-canvas { width: 100%; height: 100%; border-radius: 8px; opacity: 0.9; }
        
        #stats-panel {
            position: absolute; top: 120px; left: 15px;
            width: 110px; padding: 10px; display: none;
            flex-direction: column; gap: 5px; font-size: 0.8rem; z-index: 19;
        }
        .stat-row { display: flex; justify-content: space-between; }
        .stat-val { font-weight: 700; color: #ffd700; }
        body.day-mode .stat-val { color: #d35400; }

        /* THEME TOGGLE FAB */
        #theme-fab {
            position: absolute; top: 15px; right: 15px;
            width: 45px; height: 45px; border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            font-size: 1.2rem; cursor: pointer; z-index: 30;
            padding-top: max(0px, env(safe-area-inset-top));
            transition: transform 0.3s;
        }
        #theme-fab:active { transform: scale(0.9); }

        /* BADGES */
        .badges-container { 
            display: flex; gap: 6px; position: absolute; top: 20px; left: 50%; 
            transform: translateX(-50%); z-index: 15;
            padding-top: env(safe-area-inset-top);
            transition: top 0.3s;
        }
        .player-badge {
            display: flex; flex-direction: column; align-items: center;
            padding: 6px 8px; background: rgba(0,0,0,0.6); border-radius: 10px;
            transition: all 0.3s; border: 2px solid transparent; min-width: 45px;
        }
        body.day-mode .player-badge { background: rgba(255,255,255,0.7); box-shadow: 0 4px 10px rgba(0,0,0,0.1); }
        .player-badge.active { transform: scale(1.15); box-shadow: 0 0 15px rgba(255,255,255,0.2); background: rgba(255,255,255,0.15); }
        body.day-mode .player-badge.active { background: white; border-width: 2px; }
        .player-badge.active[data-p="0"] { border-color: var(--red); }
        .player-badge.active[data-p="1"] { border-color: var(--green); }
        .player-badge.active[data-p="2"] { border-color: var(--yellow); }
        .player-badge.active[data-p="3"] { border-color: var(--blue); }
        .p-icon { font-size: 1rem; margin-bottom: 2px; }
        .p-dots { display: flex; gap: 2px; }
        .dot { width: 5px; height: 5px; border-radius: 50%; background: #444; }
        .dot.home { background: #ffd700; box-shadow: 0 0 4px #ffd700; }
        body.day-mode .dot.home { background: #f1c40f; box-shadow: none; }

        /* SETTINGS */
        #settings-btn {
            position: absolute; bottom: 30px; right: 20px;
            width: 45px; height: 45px; border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            font-size: 1.2rem; cursor: pointer; z-index: 50;
            padding-bottom: env(safe-area-inset-bottom);
        }
        #settings-menu {
            position: absolute; bottom: 90px; right: 20px;
            width: 200px; padding: 15px; display: flex; flex-direction: column; gap: 12px;
            transform: scale(0); transform-origin: bottom right; transition: transform 0.3s ease;
            z-index: 49;
        }
        #settings-menu.open { transform: scale(1); }
        .setting-row { display: flex; justify-content: space-between; align-items: center; font-size: 0.9rem; font-weight: 600; }
        .toggle-switch {
            width: 40px; height: 20px; background: rgba(255,255,255,0.2);
            border-radius: 20px; position: relative; cursor: pointer; border: 1px solid rgba(255,255,255,0.1);
        }
        body.day-mode .toggle-switch { background: rgba(0,0,0,0.1); border-color: rgba(0,0,0,0.1); }
        .toggle-knob {
            width: 16px; height: 16px; background: white; border-radius: 50%;
            position: absolute; top: 1px; left: 2px; transition: 0.2s;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }
        .toggle-switch.on { background: var(--green); }
        .toggle-switch.on .toggle-knob { left: 20px; }
        .btn-restart {
            background: var(--red); color: white; border: none; padding: 10px; border-radius: 8px;
            font-weight: 700; cursor: pointer; margin-top: 5px; width: 100%;
        }

        /* --- THREE.JS DICE CONTAINER --- */
        #dice-box {
            position: absolute;
            bottom: 10%; 
            left: 50%; transform: translateX(-50%);
            width: 120px; height: 120px;
            z-index: 20;
            pointer-events: auto;
            cursor: pointer;
            padding-bottom: env(safe-area-inset-bottom);
        }
        #diceCanvas {
            width: 100%; height: 100%;
            display: block;
        }

        /* STATUS TEXT */
        #status-text {
            position: absolute; 
            bottom: calc(10% + 110px); /* Above Dice */
            left: 50%; transform: translateX(-50%);
            padding: 8px 25px; border-radius: 50px;
            font-weight: 800; font-size: 1rem; letter-spacing: 1px;
            text-align: center; white-space: nowrap; opacity: 0; transition: opacity 0.3s;
            border: 1px solid var(--glass-border); text-shadow: 0 2px 4px var(--shadow-color);
            color: var(--text-color);
            z-index: 10; margin-bottom: env(safe-area-inset-bottom);
        }
        #status-text.show { opacity: 1; }

        /* SCREENS */
        #landing-screen {
            position: fixed; top:0; left:0; width:100%; height:100%;
            background: rgba(10, 5, 30, 0.4); backdrop-filter: blur(4px);
            z-index: 100; display: flex; justify-content: center; align-items: center; transition: opacity 0.5s;
        }
        .welcome-card { 
            text-align: center; padding: 40px; max-width: 450px; width: 85%;
            animation: float 6s ease-in-out infinite; border: 1px solid rgba(255,255,255,0.3);
        }
        @keyframes float { 0%,100%{transform:translateY(0);} 50%{transform:translateY(-10px);} }
        .game-title { 
            font-size: 3.5rem; font-weight: 900; margin-bottom: 10px; line-height: 1;
            background: linear-gradient(135deg, #fff, #a5b4fc); -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 15px rgba(108, 99, 255, 0.5));
        }
        body.day-mode .game-title { background: linear-gradient(135deg, #6C63FF, #4834d4); -webkit-background-clip: text; }

        .btn-start, .btn-secondary {
            color: white; border: none; padding: 16px; width: 100%;
            font-size: 1.1rem; font-weight: 800; border-radius: 50px;
            cursor: pointer; margin-top: 10px; transition: transform 0.2s;
        }
        .btn-start { background: linear-gradient(135deg, #6C63FF, #4834d4); box-shadow: 0 0 25px rgba(108, 99, 255, 0.5); }
        .btn-secondary { background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); }
        body.day-mode .btn-secondary { background: rgba(0,0,0,0.05); border-color: rgba(0,0,0,0.1); color: #333; }
        .btn-start:active, .btn-secondary:active { transform: scale(0.95); }

        .modal-overlay {
            position: fixed; top:0; left:0; width:100%; height:100%;
            background: rgba(0,0,0,0.85); z-index: 200; display: none; justify-content: center; align-items: center; backdrop-filter: blur(5px);
        }
        body.day-mode .modal-overlay { background: rgba(255,255,255,0.8); }
        .modal-content { width: 85%; max-width: 400px; padding: 30px; text-align: left; }
        .modal-title { font-size: 1.5rem; margin-bottom: 15px; color: #ffd700; display:flex; align-items:center; gap:10px;}
        body.day-mode .modal-title { color: #d35400; }
        .rule-item { margin-bottom: 12px; font-size: 0.95rem; line-height: 1.4; display:flex; gap:10px; }
        .rule-icon { color: #6C63FF; width: 20px; }

        @media (max-width: 600px) {
            .game-title { font-size: 2.8rem; }
            #stats-panel { top: 110px; }
            .badges-container { top: 85px; } 
            #minimap-container { width: 80px; height: 80px; }
            #dice-box { bottom: 18%; }
            #status-text { bottom: calc(18% + 100px); }
        }
    </style>
</head>
<body onclick="startAudioEngine()">

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer" style="opacity: 0;"> 
        <div id="minimap-container" class="glass-panel">
            <canvas id="minimap-canvas" width="100" height="100"></canvas>
        </div>
        <div id="stats-panel" class="glass-panel">
            <div style="font-size:0.7rem; opacity:0.7; margin-bottom:5px;">LIVE STATS</div>
            <div class="stat-row"><span>MOVES:</span> <span class="stat-val" id="stat-moves">0</span></div>
            <div class="stat-row"><span>KILLS:</span> <span class="stat-val" id="stat-kills">0</span></div>
        </div>
        <div id="theme-fab" class="glass-panel" onclick="toggleTheme(this)">
            <i class="fas fa-moon" id="theme-icon"></i>
        </div>
        <div class="badges-container">
            <div class="player-badge active" id="badge0" data-p="0"><i class="fas fa-user p-icon" style="color:var(--red)"></i><div class="p-dots" id="dots0"></div></div>
            <div class="player-badge" id="badge1" data-p="1"><i class="fas fa-robot p-icon" style="color:var(--green)"></i><div class="p-dots" id="dots1"></div></div>
            <div class="player-badge" id="badge2" data-p="2"><i class="fas fa-robot p-icon" style="color:var(--yellow)"></i><div class="p-dots" id="dots2"></div></div>
            <div class="player-badge" id="badge3" data-p="3"><i class="fas fa-robot p-icon" style="color:var(--blue)"></i><div class="p-dots" id="dots3"></div></div>
        </div>
        <div id="status-text" class="glass-panel">YOUR TURN</div>
        <div id="settings-btn" class="glass-panel" onclick="toggleSettingsMenu()">
            <i class="fas fa-cog"></i>
        </div>
        <div id="settings-menu" class="glass-panel">
            <div class="setting-row">
                <span>Minimap</span>
                <div class="toggle-switch on" onclick="toggleSwitch('map', this)"><div class="toggle-knob"></div></div>
            </div>
            <div class="setting-row">
                <span>Stats</span>
                <div class="toggle-switch" onclick="toggleSwitch('stats', this)"><div class="toggle-knob"></div></div>
            </div>
            <div class="setting-row">
                <span>Sound</span>
                <div class="toggle-switch on" onclick="toggleSwitch('sound', this)"><div class="toggle-knob"></div></div>
            </div>
            <div class="setting-row">
                <span>Day Mode</span>
                <div class="toggle-switch" id="day-switch" onclick="toggleTheme(this)"><div class="toggle-knob"></div></div>
            </div>
            <button class="btn-restart" onclick="if(confirm('Restart Game?')) location.reload()"><i class="fas fa-redo"></i> NEW GAME</button>
        </div>

        <div id="dice-box" onclick="handleDiceClick()">
            <canvas id="diceCanvas"></canvas>
        </div>
    </div>

    <div id="landing-screen">
        <div class="welcome-card glass-panel">
            <h1 class="game-title">LUDO 3D</h1>
            <p style="margin-bottom:20px; opacity:0.8; font-weight:500; letter-spacing:1px;">CONTEST EDITION</p>
            <button class="btn-start" id="startBtn">PLAY GAME</button>
            <button class="btn-secondary" onclick="openRules()">HOW TO PLAY</button>
        </div>
    </div>

    <div id="rules-modal" class="modal-overlay">
        <div class="modal-content glass-panel">
            <div class="modal-title"><i class="fas fa-book"></i> Rules</div>
            <div class="rule-item"><i class="fas fa-dice-one rule-icon"></i> <span>Roll a <strong>6</strong> to leave your base.</span></div>
            <div class="rule-item"><i class="fas fa-star rule-icon"></i> <span><strong>Star</strong> spaces are safe zones.</span></div>
            <div class="rule-item"><i class="fas fa-skull rule-icon"></i> <span>Land on enemies to <strong>capture</strong> them.</span></div>
            <div class="rule-item"><i class="fas fa-trophy rule-icon"></i> <span>Get all 4 pieces to center to <strong>win</strong>.</span></div>
            <button class="btn-start" onclick="closeRules()">GOT IT</button>
        </div>
    </div>

    <div id="win-modal" class="modal-overlay">
        <div class="modal-content glass-panel" style="text-align:center;">
            <i class="fas fa-trophy" style="font-size:5rem; color:#ffd700; margin-bottom:20px;"></i>
            <h1 class="game-title" id="winner-name" style="font-size:2.5rem;">RED WINS!</h1>
            <button class="btn-start" onclick="location.reload()">PLAY AGAIN</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <script>
        // CONFIG
        const COLORS = [0xff4757, 0x2ed573, 0xffa502, 0x1e90ff];
        const HEX_STRINGS = ['#ff4757', '#2ed573', '#ffa502', '#1e90ff'];
        const NAMES = ['YOU', 'GREEN', 'YELLOW', 'BLUE'];
        
        let scene, camera, renderer, raycaster, mouse;
        let pieces = [], boardGroup, stars, clouds, sun;
        let currentPlayer = 0;
        let gameState = 'MENU'; 
        let diceValue = 1;
        let soundEnabled = true;
        let dayMode = false;
        let validMoves = [];
        let orbitAngle = 0;
        let gameStats = { moves: 0, kills: 0 };
        let introInterval;
        
        // DICE SCENE VARS
        let diceScene, diceCamera, diceRenderer, diceMesh;
        let diceRotX = 0, diceRotY = 0, diceRotZ = 0;

        const AudioCtx = window.AudioContext || window.webkitAudioContext;
        let ctx;

        function startAudioEngine() {
            if(!ctx) { ctx = new AudioCtx(); playIntroMusic(); }
            if(ctx.state === 'suspended') { ctx.resume().then(() => playIntroMusic()); }
        }

        function playIntroMusic() {
            if(introInterval) return;
            let noteIdx = 0;
            const introNotes = [261.63, 329.63, 392.00, 493.88]; 
            introInterval = setInterval(() => {
                if(gameState !== 'MENU') { clearInterval(introInterval); return; }
                if(soundEnabled && ctx) {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.frequency.setValueAtTime(introNotes[noteIdx % 4], ctx.currentTime);
                    osc.type = 'sine';
                    gain.gain.setValueAtTime(0.1, ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 1.5);
                    osc.connect(gain); gain.connect(ctx.destination);
                    osc.start(); osc.stop(ctx.currentTime + 1.5);
                    noteIdx++;
                }
            }, 500);
        }

        const sfx = {
            roll: () => { 
                if(!soundEnabled || !ctx) return;
                const bufferSize = ctx.sampleRate * 0.3;
                const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                const noise = ctx.createBufferSource();
                noise.buffer = buffer;
                const gain = ctx.createGain();
                gain.gain.setValueAtTime(0.4, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);
                noise.connect(gain); gain.connect(ctx.destination);
                noise.start();
            },
            move: () => {
                if(!soundEnabled || !ctx) return;
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.frequency.setValueAtTime(400, ctx.currentTime);
                osc.frequency.linearRampToValueAtTime(600, ctx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.2, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.1);
                osc.connect(gain); gain.connect(ctx.destination);
                osc.start(); osc.stop(ctx.currentTime + 0.1);
            },
            kill: () => {
                if(!soundEnabled || !ctx) return;
                const osc = ctx.createOscillator();
                osc.type = 'sawtooth';
                const gain = ctx.createGain();
                osc.frequency.setValueAtTime(150, ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(50, ctx.currentTime + 0.2);
                gain.gain.setValueAtTime(0.4, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.2);
                osc.connect(gain); gain.connect(ctx.destination);
                osc.start(); osc.stop(ctx.currentTime + 0.2);
            },
            win: () => {
                if(!soundEnabled || !ctx) return;
                [523, 659, 784, 1047, 523, 659, 784, 1047].forEach((f, i) => {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    osc.type = 'square';
                    osc.frequency.setValueAtTime(f, ctx.currentTime + i*0.1);
                    gain.gain.setValueAtTime(0.1, ctx.currentTime + i*0.1);
                    gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + i*0.1 + 0.3);
                    osc.connect(gain); gain.connect(ctx.destination);
                    osc.start(ctx.currentTime + i*0.1); osc.stop(ctx.currentTime + i*0.1 + 0.3);
                });
            }
        };

        const getPath = (pid) => {
            const perimeter = [
                {x:6,y:13},{x:6,y:12},{x:6,y:11},{x:6,y:10},{x:6,y:9}, {x:5,y:8},{x:4,y:8},{x:3,y:8},{x:2,y:8},{x:1,y:8},{x:0,y:8},
                {x:0,y:7},{x:0,y:6},{x:1,y:6},{x:2,y:6},{x:3,y:6},{x:4,y:6},{x:5,y:6}, {x:6,y:5},{x:6,y:4},{x:6,y:3},{x:6,y:2},{x:6,y:1},{x:6,y:0},
                {x:7,y:0},{x:8,y:0},{x:8,y:1},{x:8,y:2},{x:8,y:3},{x:8,y:4},{x:8,y:5}, {x:9,y:6},{x:10,y:6},{x:11,y:6},{x:12,y:6},{x:13,y:6},{x:14,y:6},
                {x:14,y:7},{x:14,y:8},{x:13,y:8},{x:12,y:8},{x:11,y:8},{x:10,y:8},{x:9,y:8}, {x:8,y:9},{x:8,y:10},{x:8,y:11},{x:8,y:12},{x:8,y:13},{x:8,y:14},
                {x:7,y:14},{x:6,y:14} 
            ];
            const offset = pid * 13;
            let path = [];
            for(let i=0; i<51; i++) path.push(perimeter[(i + offset) % 52]);
            if(pid===0) path.push({x:7,y:13},{x:7,y:12},{x:7,y:11},{x:7,y:10},{x:7,y:9},{x:7,y:8});
            if(pid===1) path.push({x:1,y:7},{x:2,y:7},{x:3,y:7},{x:4,y:7},{x:5,y:7},{x:6,y:7});
            if(pid===2) path.push({x:7,y:1},{x:7,y:2},{x:7,y:3},{x:7,y:4},{x:7,y:5},{x:7,y:6});
            if(pid===3) path.push({x:13,y:7},{x:12,y:7},{x:11,y:7},{x:10,y:7},{x:9,y:7},{x:8,y:7});
            return path;
        };
        const PATHS = [getPath(0), getPath(1), getPath(2), getPath(3)];
        const YARDS = [
            [{x:1,y:13}, {x:4,y:13}, {x:1,y:10}, {x:4,y:10}], 
            [{x:1,y:1}, {x:4,y:1}, {x:1,y:4}, {x:4,y:4}],     
            [{x:13,y:1}, {x:10,y:1}, {x:13,y:4}, {x:10,y:4}], 
            [{x:13,y:13}, {x:10,y:13}, {x:13,y:10}, {x:10,y:10}] 
        ];

        function init() {
            // Main Scene
            const cvs = document.getElementById('gameCanvas');
            renderer = new THREE.WebGLRenderer({ canvas: cvs, antialias: true, alpha: true });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x0f0c29, 0.03); 
            camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 100);
            camera.position.set(0, 30, 20);

            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const sunLight = new THREE.DirectionalLight(0xffffff, 0.8);
            sunLight.position.set(10, 20, 10);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.width = 1024; sunLight.shadow.mapSize.height = 1024;
            scene.add(sunLight);

            createBoard();
            createPieces();
            createStars();
            createEnvironment(); 
            
            // Dice Scene (THREE.JS)
            createDice();

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            window.addEventListener('resize', onResize);
            window.addEventListener('touchstart', onPieceClick, {passive: false});
            window.addEventListener('mousedown', onPieceClick);
            
            document.getElementById('startBtn').addEventListener('click', startGame);

            animate();
        }

        // THREE.JS DICE SETUP
        function createDice() {
            const canvas = document.getElementById('diceCanvas');
            diceScene = new THREE.Scene();
            diceCamera = new THREE.PerspectiveCamera(45, 1, 0.1, 100);
            diceCamera.position.z = 5;
            
            diceRenderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true, antialias: true });
            diceRenderer.setSize(120, 120); // Match container size
            
            // Lights for dice
            const amb = new THREE.AmbientLight(0xffffff, 0.8);
            diceScene.add(amb);
            const dir = new THREE.DirectionalLight(0xffffff, 0.8);
            dir.position.set(5, 5, 5);
            diceScene.add(dir);

            // Dice Mesh
            const geometry = new THREE.BoxGeometry(1.8, 1.8, 1.8);
            
            // Create textures for faces
            const materials = [];
            for (let i = 1; i <= 6; i++) {
                const cvs = document.createElement('canvas');
                cvs.width = 128; cvs.height = 128;
                const ctx = cvs.getContext('2d');
                ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,128,128);
                // Draw dots
                ctx.fillStyle = '#000000';
                drawDots(ctx, i);
                // Border for slight "inset" look
                ctx.strokeStyle = '#e0e0e0'; ctx.lineWidth = 10; ctx.strokeRect(0,0,128,128);
                
                const tex = new THREE.CanvasTexture(cvs);
                materials.push(new THREE.MeshStandardMaterial({ map: tex }));
            }
            
            diceMesh = new THREE.Mesh(geometry, materials);
            diceScene.add(diceMesh);
            
            // Set initial rotation (6)
            diceMesh.rotation.x = Math.PI/2; 
        }

        function drawDots(ctx, n) {
            const r = 12;
            const c = 64;
            const o = 35;
            const dot = (x,y) => { ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); };
            if(n%2===1) dot(c,c);
            if(n>1) { dot(c-o,c-o); dot(c+o,c+o); }
            if(n>3) { dot(c-o,c+o); dot(c+o,c-o); }
            if(n===6) { dot(c-o,c); dot(c+o,c); }
        }

        function createEnvironment() {
            const geo = new THREE.BufferGeometry();
            const pos = [];
            for(let i=0; i<800; i++) pos.push((Math.random()-0.5)*80, Math.random()*40, (Math.random()-0.5)*80);
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            const mat = new THREE.PointsMaterial({color:0xffffff, size:0.15, transparent:true, opacity:0.8});
            stars = new THREE.Points(geo, mat);
            scene.add(stars);

            clouds = new THREE.Group();
            const cloudGeo = new THREE.SphereGeometry(1.5, 7, 7);
            const cloudMat = new THREE.MeshBasicMaterial({color: 0xffffff, transparent: true, opacity: 0.9});
            
            for(let i=0; i<8; i++) {
                const c = new THREE.Group();
                for(let j=0; j<4; j++) {
                    const puff = new THREE.Mesh(cloudGeo, cloudMat);
                    puff.position.set(Math.random()*3, Math.random()*1.5, Math.random()*3);
                    puff.scale.setScalar(1 + Math.random()*0.5);
                    c.add(puff);
                }
                c.position.set((Math.random()-0.5)*50, 8 + Math.random()*5, (Math.random()-0.5)*40);
                clouds.add(c);
            }
            
            const sunGeo = new THREE.SphereGeometry(4, 16, 16);
            const sunMat = new THREE.MeshBasicMaterial({color: 0xffaa00});
            sun = new THREE.Mesh(sunGeo, sunMat);
            sun.position.set(-25, 20, -25);
        }

        function createBoard() {
            boardGroup = new THREE.Group();
            const base = new THREE.Mesh(new THREE.BoxGeometry(16, 0.5, 16), new THREE.MeshStandardMaterial({color: 0x1a1a1a}));
            base.position.y = -0.25; base.receiveShadow = true;
            boardGroup.add(base);

            const cellGeo = new THREE.BoxGeometry(0.95, 0.1, 0.95);
            const whiteMat = new THREE.MeshStandardMaterial({color: 0xffffff});
            const createCell = (x, y, color) => {
                const mesh = new THREE.Mesh(cellGeo, color ? new THREE.MeshStandardMaterial({color}) : whiteMat);
                mesh.position.set(x - 7, 0.05, y - 7);
                mesh.receiveShadow = true;
                boardGroup.add(mesh);
            };

            for(let x=0; x<15; x++) {
                for(let y=0; y<15; y++) {
                    if(x<6 && y>=9) { createCell(x,y, COLORS[0]); continue; }
                    if(x<6 && y<6) { createCell(x,y, COLORS[1]); continue; }
                    if(x>=9 && y<6) { createCell(x,y, COLORS[2]); continue; }
                    if(x>=9 && y>=9) { createCell(x,y, COLORS[3]); continue; }
                    if(x>=6 && x<=8 && y>=6 && y<=8) {
                        if(!(x==7 && y==7)) createCell(x,y, 0xffd700);
                        continue;
                    }
                    let col = null;
                    if(x===7 && y>8 && y<14) col = COLORS[0];
                    if(y===7 && x>0 && x<6) col = COLORS[1];
                    if(x===7 && y>0 && y<6) col = COLORS[2];
                    if(y===7 && x>8 && x<14) col = COLORS[3];
                    if((x==6 && y==13) || (x==8 && y==1) || (x==1 && y==8) || (x==13 && y==6)) col = 0x888888;
                    if((x>=6 && x<=8) || (y>=6 && y<=8)) createCell(x,y, col);
                }
            }
            scene.add(boardGroup);
        }

        function createPieces() {
            const points = [];
            points.push(new THREE.Vector2(0,0)); points.push(new THREE.Vector2(0.35,0));
            points.push(new THREE.Vector2(0.35,0.2)); points.push(new THREE.Vector2(0.2,0.5));
            points.push(new THREE.Vector2(0,0.6));
            const geo = new THREE.LatheGeometry(points, 20); geo.translate(0,0,0);

            for(let p=0; p<4; p++) {
                pieces[p] = [];
                for(let i=0; i<4; i++) {
                    const mat = new THREE.MeshPhysicalMaterial({color: COLORS[p], metalness:0.3, roughness:0.2, clearcoat:1});
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.castShadow = true;
                    const ring = new THREE.Mesh(new THREE.RingGeometry(0.4, 0.5, 32), new THREE.MeshBasicMaterial({color: 0xffffff, transparent:true, opacity:0}));
                    ring.rotation.x = -Math.PI/2; ring.position.y = 0.02;
                    mesh.add(ring);
                    mesh.userData = { p: p, id: i, step: -1, ring: ring };
                    mesh.position.set(YARDS[p][i].x - 7, 0, YARDS[p][i].y - 7);
                    scene.add(mesh);
                    pieces[p].push(mesh);
                }
            }
        }

        function createStars() {
            const safes = [[6,13],[8,1],[1,8],[13,6],[8,12],[6,2],[2,6],[12,8]];
            safes.forEach(pos => {
                const star = new THREE.Mesh(new THREE.OctahedronGeometry(0.15), new THREE.MeshBasicMaterial({color: 0xffd700}));
                star.position.set(pos[0]-7, 0.3, pos[1]-7);
                scene.add(star);
                gsap.to(star.position, {y: 0.5, duration: 1, yoyo: true, repeat: -1});
                gsap.to(star.rotation, {y: Math.PI, duration: 2, repeat: -1, ease: "none"});
            });
        }

        // LOGIC
        function startGame() {
            clearInterval(introInterval);
            document.getElementById('landing-screen').style.opacity = 0;
            document.getElementById('ui-layer').style.opacity = 1;
            setTimeout(() => {
                document.getElementById('landing-screen').style.display = 'none';
                gameState = 'TURN_START';
                currentPlayer = 0;
                startTurn();
            }, 500);
        }

        function startTurn() {
            gameState = 'TURN_START';
            document.querySelectorAll('.player-badge').forEach(b => b.classList.remove('active'));
            document.getElementById(`badge${currentPlayer}`).classList.add('active');
            focusCamera(currentPlayer);
            
            // Dice Color Update via materials (skip for now or tint light?)
            // We'll keep dice white standard

            if(currentPlayer === 0) {
                setStatus("YOUR TURN");
            } else {
                setStatus(`${NAMES[currentPlayer]}...`);
                setTimeout(aiRoll, 1000);
            }
        }

        function handleDiceClick() {
            if(currentPlayer !== 0 || gameState !== 'TURN_START') return;
            performRoll();
        }

        function aiRoll() { performRoll(); }

        function performRoll() {
            gameState = 'ROLLING';
            sfx.roll();
            
            // PHYSICS ANIMATION WITH GSAP (THREE.JS)
            // Tumble
            gsap.to(diceMesh.rotation, {
                x: `+=${Math.PI * 4 + Math.random()}`,
                y: `+=${Math.PI * 4 + Math.random()}`,
                duration: 0.6,
                ease: "power1.inOut"
            });
            
            // Jump
            gsap.to(diceMesh.position, {
                y: 2,
                duration: 0.3,
                yoyo: true,
                repeat: 1,
                ease: "power2.out",
                onComplete: finalizeRoll
            });
        }

        function finalizeRoll() {
            diceValue = Math.ceil(Math.random() * 6);
            
            // Rotate to target face
            // 1: x0, y0
            // 2: x-90, y0 (Top face 1, Right face 5...) 
            // Mapping standard box UV to face: 1=right, 2=left, 3=top, 4=bottom, 5=front, 6=back
            // Let's rely on standard rotation map
            const r = Math.PI/2;
            let tx=0, ty=0, tz=0;
            
            // Our texture array: 0=1, 1=2, 2=3, 3=4, 4=5, 5=6
            // BoxGeometry faces order: Right(0), Left(1), Top(2), Bottom(3), Front(4), Back(5)
            // So face 1 is Right (+x), 2 is Left (-x), 3 is Top (+y), 4 is Bottom (-y), 5 is Front (+z), 6 is Back (-z)
            
            switch(diceValue) {
                case 1: ty = -r; break; // Show Right face
                case 2: ty = r; break;  // Show Left face
                case 3: tx = r; break;  // Show Top face
                case 4: tx = -r; break; // Show Bottom face
                case 5: break; // Show Front face (0,0,0) - Actually Front is +z
                case 6: ty = Math.PI; break; // Show Back face
            }
            
            // Note: BoxGeometry default front is +Z. Camera is at +Z. So we see face 5 (Front) by default.
            // Face 5 (index 4) maps to "5 dots"? 
            // Let's correct material mapping:
            // Mat Index: 0=Right, 1=Left, 2=Top, 3=Bottom, 4=Front, 5=Back
            // We generated mats 1..6 in loop.
            // Mat[0] = 1 dot
            // Mat[1] = 2 dots
            // Mat[2] = 3 dots
            // Mat[3] = 4 dots
            // Mat[4] = 5 dots
            // Mat[5] = 6 dots
            
            // So if roll is 1: We want Right face to point to camera (+Z) -> Rotate Y -90
            // If roll is 5: We want Front face to point to camera -> Rotate 0
            
            // Correction logic:
            switch(diceValue) {
                case 1: tx=0; ty=-r; break;
                case 2: tx=0; ty=r; break;
                case 3: tx=r; ty=0; break;
                case 4: tx=-r; ty=0; break;
                case 5: tx=0; ty=0; break;
                case 6: tx=0; ty=Math.PI; break;
            }

            gsap.to(diceMesh.rotation, {
                x: tx, y: ty, z: 0,
                duration: 0.2,
                onComplete: checkValidMoves
            });
        }

        // ... GAMEPLAY LOGIC (Same as previous stable) ...
        
        function checkValidMoves() {
            validMoves = getValidMoves(currentPlayer, diceValue);
            if(validMoves.length === 0) {
                setStatus(`NO MOVES`); setTimeout(endTurn, 1000);
            } else {
                if(currentPlayer === 0) {
                    gameState = 'WAITING_INPUT'; setStatus(`TAP PIECE`); highlightPieces(true);
                    if(validMoves.length === 1 && validMoves[0].userData.step !== -1) movePiece(validMoves[0]);
                } else {
                    gameState = 'AI_THINKING'; setTimeout(aiDecide, 800);
                }
            }
        }

        function aiDecide() {
            let best = validMoves[0], maxScore = -100;
            validMoves.forEach(p => {
                let score = Math.random() * 10;
                if(p.userData.step === -1) score += 50; 
                else {
                    const dest = p.userData.step + diceValue;
                    if(dest >= PATHS[currentPlayer].length-1) score += 100; 
                    score += dest;
                }
                if(score > maxScore) { maxScore = score; best = p; }
            });
            movePiece(best);
        }

        function movePiece(piece) {
            gameState = 'MOVING'; highlightPieces(false);
            if(currentPlayer === 0) { gameStats.moves++; updateStatsUI(); }
            let cur = piece.userData.step;
            let target = cur + diceValue;
            if(cur === -1) {
                jumpPiece(piece, PATHS[currentPlayer][0].x, PATHS[currentPlayer][0].y, () => {
                    piece.userData.step = 0; checkTurnEnd(true); 
                });
            } else {
                let step = 1;
                const doStep = () => {
                    if(step <= diceValue) {
                        const next = PATHS[currentPlayer][cur + step];
                        if(!next) { checkTurnEnd(false); return; }
                        jumpPiece(piece, next.x, next.y, () => {
                            step++;
                            if(step > diceValue) { piece.userData.step = target; handleLanding(piece); } 
                            else doStep();
                        });
                    }
                };
                doStep();
            }
        }

        function jumpPiece(piece, tx, ty, onComplete) {
            sfx.move();
            const tl = gsap.timeline({onComplete: onComplete});
            tl.to(piece.position, { x: tx-7, z: ty-7, duration: 0.2, ease: "linear" }, 0);
            tl.to(piece.position, { y: 1.5, duration: 0.1, yoyo: true, repeat: 1, ease: "power1.out" }, 0);
        }

        function handleLanding(piece) {
            if(piece.userData.step >= PATHS[currentPlayer].length - 1) {
                sfx.win(); updateBadgeDots(currentPlayer);
                if(pieces[currentPlayer].every(p => p.userData.step >= PATHS[currentPlayer].length - 1)) {
                    document.getElementById('winner-name').innerText = `${NAMES[currentPlayer]} WINS!`;
                    document.getElementById('win-modal').style.display = 'flex'; return;
                }
                checkTurnEnd(true); return;
            }
            const px = Math.round(piece.position.x + 7);
            const py = Math.round(piece.position.z + 7);
            const isSafe = (px==6&&py==13)||(px==8&&py==1)||(px==1&&py==8)||(px==13&&py==6)||(px==8&&py==12)||(px==6&&py==2)||(px==2&&py==6)||(px==12&&py==8);
            let captured = false;
            if(!isSafe) {
                for(let op=0; op<4; op++) {
                    if(op === currentPlayer) continue;
                    pieces[op].forEach(en => {
                        const ex = Math.round(en.position.x + 7);
                        const ey = Math.round(en.position.z + 7);
                        if(ex === px && ey === py && en.userData.step !== -1) {
                            captureAnim(en); captured = true;
                            if(currentPlayer === 0) { gameStats.kills++; updateStatsUI(); }
                        }
                    });
                }
            }
            if(captured) { setStatus("CAPTURE! BONUS!"); setTimeout(() => checkTurnEnd(true), 1000); }
            else checkTurnEnd(diceValue === 6);
        }

        function captureAnim(piece) {
            sfx.kill();
            piece.userData.step = -1;
            const h = YARDS[piece.userData.p][piece.userData.id];
            gsap.to(piece.position, {x: h.x-7, z: h.y-7, y: 5, duration: 0.6, ease: "back.in(1.7)", onComplete: ()=>piece.position.y=0});
        }

        function checkTurnEnd(bonus) {
            if(bonus) { gameState = 'TURN_START'; startTurn(); } else endTurn();
        }
        function endTurn() { currentPlayer = (currentPlayer + 1) % 4; startTurn(); }

        function getValidMoves(pid, roll) {
            let res = [];
            pieces[pid].forEach(p => {
                if(p.userData.step === -1) { if(roll === 6) res.push(p); }
                else if(p.userData.step + roll < PATHS[pid].length) res.push(p);
            });
            return res;
        }
        function highlightPieces(on) {
            validMoves.forEach(p => {
                p.userData.ring.material.opacity = on ? 1 : 0;
                if(on) gsap.to(p.position, {y: 0.5, duration: 0.5, yoyo: true, repeat: -1, overwrite: true});
                else { gsap.killTweensOf(p.position); p.position.y = 0; }
            });
        }
        function updateBadgeDots(pid) {
            const el = document.getElementById(`dots${pid}`); el.innerHTML = '';
            const c = pieces[pid].filter(p => p.userData.step >= PATHS[pid].length - 1).length;
            for(let i=0; i<4; i++) {
                const d = document.createElement('div'); d.className = 'dot' + (i<c ? ' home' : ''); el.appendChild(d);
            }
        }
        function updateStatsUI() {
            document.getElementById('stat-moves').textContent = gameStats.moves;
            document.getElementById('stat-kills').textContent = gameStats.kills;
        }
        function setStatus(text) {
            const el = document.getElementById('status-text'); el.textContent = text;
            el.style.borderColor = HEX_STRINGS[currentPlayer]; el.classList.add('show');
        }
        function focusCamera(pid) {
            const isMobile = window.innerWidth < 768;
            const yHeight = isMobile ? 38 : 22; 
            const dist = isMobile ? 10 : 18;
            const angles = [{x:0,z:dist}, {x:-dist,z:0}, {x:0,z:-dist}, {x:dist,z:0}];
            gsap.to(camera.position, {
                x: angles[pid].x, z: angles[pid].z, y: yHeight,
                duration: 1.5, ease: "power2.inOut",
                onUpdate: () => camera.lookAt(0,0,0)
            });
        }
        function drawMinimap() {
            const ctx = document.getElementById('minimap-canvas').getContext('2d');
            ctx.fillStyle = dayMode ? '#e0e7ff' : '#1a1a1a'; ctx.fillRect(0,0,100,100);
            pieces.forEach(row => row.forEach(p => {
                if(p.userData.step >= PATHS[p.userData.p].length-1) return;
                const x = ((p.position.x+7)/14)*80 + 10;
                const y = ((p.position.z+7)/14)*80 + 10;
                ctx.fillStyle = HEX_STRINGS[p.userData.p];
                ctx.beginPath(); ctx.arc(x,y,3,0,Math.PI*2); ctx.fill();
            }));
        }

        function toggleSettingsMenu() { document.getElementById('settings-menu').classList.toggle('open'); }
        function toggleSwitch(type, el) {
            el.classList.toggle('on'); const isOn = el.classList.contains('on');
            if(type === 'map') document.getElementById('minimap-container').style.display = isOn ? 'flex' : 'none';
            if(type === 'stats') document.getElementById('stats-panel').style.display = isOn ? 'flex' : 'none';
            if(type === 'sound') soundEnabled = isOn;
        }
        function toggleTheme(el) {
            const fab = document.getElementById('theme-fab');
            const icon = document.getElementById('theme-icon');
            const switchEl = document.getElementById('day-switch');
            dayMode = !dayMode;
            if(dayMode) {
                document.body.classList.add('day-mode');
                icon.className = 'fas fa-sun'; icon.style.color = '#f1c40f';
                if(switchEl) switchEl.classList.add('on');
            } else {
                document.body.classList.remove('day-mode');
                icon.className = 'fas fa-moon'; icon.style.color = '#ffffff';
                if(switchEl) switchEl.classList.remove('on');
            }
            scene.fog = new THREE.FogExp2(dayMode ? 0x87CEEB : 0x0f0c29, dayMode ? 0.002 : 0.03);
            if(dayMode) { scene.remove(stars); scene.add(clouds); scene.add(sun); }
            else { scene.add(stars); scene.remove(clouds); scene.remove(sun); }
        }
        function openRules() { document.getElementById('rules-modal').style.display = 'flex'; }
        function closeRules() { document.getElementById('rules-modal').style.display = 'none'; }

        function onPieceClick(e) {
            if(gameState !== 'WAITING_INPUT' || currentPlayer !== 0) return;
            e.preventDefault();
            const cx = e.touches ? e.touches[0].clientX : e.clientX;
            const cy = e.touches ? e.touches[0].clientY : e.clientY;
            mouse.x = (cx / window.innerWidth) * 2 - 1; mouse.y = -(cy / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(pieces[0]);
            if(intersects.length > 0) {
                const p = intersects[0].object;
                if(validMoves.includes(p)) movePiece(p);
            }
        }
        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight);
        }
        function animate() {
            requestAnimationFrame(animate); 
            renderer.render(scene, camera); 
            
            // Dice render
            if(diceRenderer && diceScene && diceCamera) {
                diceRenderer.render(diceScene, diceCamera);
            }
            
            drawMinimap();
            
            if(gameState === 'MENU') {
                orbitAngle += 0.003;
                camera.position.x = Math.sin(orbitAngle) * 25;
                camera.position.z = Math.cos(orbitAngle) * 25;
                camera.position.y = 25; camera.lookAt(0,0,0);
            }
            if(clouds) clouds.children.forEach(c => {
                c.position.x += 0.02;
                if(c.position.x > 30) c.position.x = -30;
            });
        }

        init();
    </script>
</body>
</html>
