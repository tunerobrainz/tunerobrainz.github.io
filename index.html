
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ludo 3D - Ultimate Mobile</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Outfit:wght@300;500;700;900&display=swap');
        
        :root {
            --red: #ff4757; --green: #2ed573; --yellow: #ffa502; --blue: #1e90ff;
            --glass-bg: rgba(15, 23, 42, 0.65);
            --glass-border: rgba(255, 255, 255, 0.15);
        }

        * { margin:0; padding:0; box-sizing:border-box; user-select:none; -webkit-tap-highlight-color:transparent; font-family:'Outfit', sans-serif; }
        
        body { 
            overflow:hidden; background: #0f0c29; color: white;
            height: 100vh; width: 100vw;
        }

        #gameCanvas { position: fixed; top: 0; left: 0; z-index: 1; outline: none; }

        /* --- UI LAYER --- */
        #ui-layer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
            transition: opacity 0.5s;
        }

        .glass-panel {
            background: var(--glass-bg);
            backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--glass-border);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            border-radius: 16px; pointer-events: auto;
        }

        /* Top HUD */
        #top-bar { 
            padding: 10px; display: flex; justify-content: space-between; align-items: flex-start; 
            padding-top: env(safe-area-inset-top); /* iPhone notch fix */
        }
        
        #minimap-container {
            width: 100px; height: 100px; padding: 5px;
            display: flex; flex-direction: column; align-items: center;
            transform: scale(0.9); transform-origin: top left;
        }
        #minimap-canvas { width: 100%; height: 100%; border-radius: 8px; opacity: 0.9; }

        /* Player Badges - Compact for Mobile */
        .badges-container { 
            display: flex; gap: 6px; position: absolute; top: 15px; left: 50%; 
            transform: translateX(-50%); 
            margin-top: env(safe-area-inset-top);
        }
        .player-badge {
            display: flex; flex-direction: column; align-items: center;
            padding: 6px 8px; background: rgba(0,0,0,0.6); border-radius: 10px;
            transition: all 0.3s; border: 2px solid transparent;
            min-width: 45px;
        }
        .player-badge.active { transform: scale(1.15); box-shadow: 0 0 15px rgba(255,255,255,0.2); background: rgba(255,255,255,0.15); }
        .player-badge.active[data-p="0"] { border-color: var(--red); }
        .player-badge.active[data-p="1"] { border-color: var(--green); }
        .player-badge.active[data-p="2"] { border-color: var(--yellow); }
        .player-badge.active[data-p="3"] { border-color: var(--blue); }
        
        .p-icon { font-size: 1rem; margin-bottom: 2px; }
        .p-dots { display: flex; gap: 2px; }
        .dot { width: 5px; height: 5px; border-radius: 50%; background: #444; }
        .dot.home { background: #ffd700; box-shadow: 0 0 4px #ffd700; }

        /* Controls */
        #controls {
            position: absolute; bottom: 30px; width: 100%;
            display: flex; justify-content: center; align-items: flex-end;
            pointer-events: none;
            padding-bottom: env(safe-area-inset-bottom);
        }

        #dice-wrapper {
            position: relative; width: 100px; height: 100px;
            pointer-events: auto; transition: transform 0.2s;
            background: rgba(255,255,255,0.1);
            border-radius: 20px;
        }
        #dice-wrapper.disabled { filter: grayscale(1); pointer-events: none; opacity: 0.6; }
        #dice-wrapper:active { transform: scale(0.9); }
        
        /* 3D Dice Animation */
        @keyframes tumble {
            0% { transform: rotateZ(0deg) rotateX(0deg) rotateY(0deg) scale(1); }
            25% { transform: rotateZ(90deg) rotateX(180deg) rotateY(45deg) scale(0.8); }
            50% { transform: rotateZ(180deg) rotateX(360deg) rotateY(90deg) scale(1.1); }
            75% { transform: rotateZ(270deg) rotateX(180deg) rotateY(135deg) scale(0.9); }
            100% { transform: rotateZ(360deg) rotateX(0deg) rotateY(180deg) scale(1); }
        }
        .rolling-anim { animation: tumble 0.4s linear infinite; }

        #dice-canvas { width: 100%; height: 100%; border-radius: 20px; }
        
        #status-text {
            position: absolute; bottom: 140px; left: 50%; transform: translateX(-50%);
            padding: 8px 20px; border-radius: 50px;
            font-weight: 800; font-size: 1rem; letter-spacing: 1px;
            text-align: center; white-space: nowrap;
            opacity: 0; transition: opacity 0.3s;
            border: 1px solid rgba(255,255,255,0.3);
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
            margin-bottom: env(safe-area-inset-bottom);
        }
        #status-text.show { opacity: 1; }

        /* --- START SCREEN (The "Premium" One) --- */
        #landing-screen {
            position: fixed; top:0; left:0; width:100%; height:100%;
            background: rgba(10, 5, 30, 0.4); 
            z-index: 100;
            display: flex; justify-content: center; align-items: center;
            backdrop-filter: blur(5px);
            transition: opacity 0.5s;
        }
        .welcome-card { 
            text-align: center; padding: 40px; max-width: 450px; width: 85%;
            animation: float 6s ease-in-out infinite;
        }
        @keyframes float { 0%,100%{transform:translateY(0);} 50%{transform:translateY(-10px);} }
        
        .game-title { 
            font-size: 3.5rem; font-weight: 900; margin-bottom: 10px; line-height: 1;
            background: linear-gradient(135deg, #fff, #a5b4fc); 
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            filter: drop-shadow(0 0 15px rgba(108, 99, 255, 0.5));
        }
        
        .feature-list {
            text-align: left; background: rgba(0,0,0,0.3); padding: 15px; border-radius: 12px;
            margin: 20px 0; font-size: 0.9rem; border: 1px solid rgba(255,255,255,0.1);
        }
        .feature-row { display: flex; align-items: center; gap: 10px; margin-bottom: 8px; color: #ddd; }
        
        .btn-start {
            background: linear-gradient(135deg, #6C63FF, #4834d4);
            color: white; border: none; padding: 16px 45px;
            font-size: 1.3rem; font-weight: 800; border-radius: 50px;
            cursor: pointer; width: 100%;
            box-shadow: 0 0 25px rgba(108, 99, 255, 0.5);
            transition: transform 0.2s;
        }
        .btn-start:active { transform: scale(0.95); }

        /* Winner Modal */
        #win-modal {
            position: fixed; top:0; left:0; width:100%; height:100%;
            background: rgba(0,0,0,0.95); display: none; z-index: 200;
            flex-direction: column; justify-content: center; align-items: center;
        }
        
        /* Mobile Adjustments */
        @media (max-width: 450px) {
            #minimap-container { display: none; } /* Hide minimap on very small screens to reduce clutter */
            .game-title { font-size: 2.8rem; }
            #dice-wrapper { width: 80px; height: 80px; }
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer" style="opacity: 0;"> <div id="top-bar">
            <div id="minimap-container" class="glass-panel">
                <canvas id="minimap-canvas" width="100" height="100"></canvas>
            </div>
            
            <div class="fab glass-panel" style="width:40px; height:40px; display:flex; justify-content:center; align-items:center; border-radius:50%; cursor:pointer;" onclick="toggleSound()">
                <i id="soundIcon" class="fas fa-volume-up"></i>
            </div>
        </div>

        <div class="badges-container">
            <div class="player-badge active" id="badge0" data-p="0"><i class="fas fa-user p-icon" style="color:var(--red)"></i><div class="p-dots" id="dots0"></div></div>
            <div class="player-badge" id="badge1" data-p="1"><i class="fas fa-robot p-icon" style="color:var(--green)"></i><div class="p-dots" id="dots1"></div></div>
            <div class="player-badge" id="badge2" data-p="2"><i class="fas fa-robot p-icon" style="color:var(--yellow)"></i><div class="p-dots" id="dots2"></div></div>
            <div class="player-badge" id="badge3" data-p="3"><i class="fas fa-robot p-icon" style="color:var(--blue)"></i><div class="p-dots" id="dots3"></div></div>
        </div>

        <div id="status-text" class="glass-panel">YOUR TURN</div>

        <div id="controls">
            <div id="dice-wrapper" class="glass-panel" onclick="handleDiceClick()">
                <canvas id="dice-canvas"></canvas>
            </div>
        </div>
    </div>

    <div id="landing-screen">
        <div class="welcome-card glass-panel">
            <h1 class="game-title">LUDO 3D</h1>
            <p style="margin-bottom:20px; opacity:0.8; font-weight:500; letter-spacing:1px;">CONTEST EDITION</p>
            
            <div class="feature-list">
                <div class="feature-row"><i class="fas fa-user" style="color:var(--red)"></i> <span>You play as Red</span></div>
                <div class="feature-row"><i class="fas fa-robot" style="color:var(--blue)"></i> <span>Smart AI Opponents</span></div>
                <div class="feature-row"><i class="fas fa-dice" style="color:white"></i> <span>Physics Animations</span></div>
            </div>
            
            <button class="btn-start" id="startBtn">TAP TO PLAY</button>
            <p style="font-size:0.7rem; margin-top:15px; opacity:0.5;">Sound enabled by tap</p>
        </div>
    </div>

    <div id="win-modal">
        <i class="fas fa-trophy" style="font-size:5rem; color:#ffd700; margin-bottom:20px;"></i>
        <h1 class="game-title" id="winner-name">RED WINS!</h1>
        <button class="btn-start" onclick="location.reload()">PLAY AGAIN</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <script>
        // --- CONFIG ---
        const COLORS = [0xff4757, 0x2ed573, 0xffa502, 0x1e90ff];
        const HEX_STRINGS = ['#ff4757', '#2ed573', '#ffa502', '#1e90ff'];
        const NAMES = ['YOU', 'CPU GREEN', 'CPU YELLOW', 'CPU BLUE'];
        
        // --- GAME STATE ---
        let scene, camera, renderer, raycaster, mouse;
        let pieces = [], boardGroup;
        let currentPlayer = 0;
        let gameState = 'MENU'; // MENU, TURN_START, ROLLING, WAITING_INPUT, MOVING, AI_THINKING
        let diceValue = 1;
        let soundEnabled = true;
        let validMoves = [];
        let orbitAngle = 0; // For cinematic menu camera

        // --- AUDIO ENGINE (Mobile Optimized) ---
        const AudioCtx = window.AudioContext || window.webkitAudioContext;
        let audioCtx; // Initialized on user interaction only

        const synth = {
            play: (freq, type, dur, vol=0.1) => {
                if(!soundEnabled || !audioCtx) return;
                if(audioCtx.state === 'suspended') audioCtx.resume();
                try {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.type = type;
                    osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                    gain.gain.setValueAtTime(vol, audioCtx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + dur);
                    osc.connect(gain);
                    gain.connect(audioCtx.destination);
                    osc.start();
                    osc.stop(audioCtx.currentTime + dur);
                } catch(e) {}
            },
            click: () => synth.play(800, 'sine', 0.1, 0.1),
            roll: () => { 
                // Rapid fire clicks
                let t = 0;
                for(let i=0; i<8; i++) {
                    setTimeout(() => synth.play(300 + Math.random()*200, 'square', 0.05, 0.05), t);
                    t += 50;
                }
            },
            move: () => synth.play(600, 'sine', 0.15, 0.1),
            kill: () => { synth.play(150,'sawtooth',0.2); setTimeout(()=>synth.play(100,'sawtooth',0.4), 150); },
            win: () => [523,659,784,1047, 523,659,784,1047].forEach((f,i)=>setTimeout(()=>synth.play(f,'square',0.4),i*100))
        };

        // --- PATH LOGIC ---
        const getPath = (pid) => {
            const perimeter = [
                {x:6,y:13},{x:6,y:12},{x:6,y:11},{x:6,y:10},{x:6,y:9}, {x:5,y:8},{x:4,y:8},{x:3,y:8},{x:2,y:8},{x:1,y:8},{x:0,y:8},
                {x:0,y:7},{x:0,y:6},{x:1,y:6},{x:2,y:6},{x:3,y:6},{x:4,y:6},{x:5,y:6}, {x:6,y:5},{x:6,y:4},{x:6,y:3},{x:6,y:2},{x:6,y:1},{x:6,y:0},
                {x:7,y:0},{x:8,y:0},{x:8,y:1},{x:8,y:2},{x:8,y:3},{x:8,y:4},{x:8,y:5}, {x:9,y:6},{x:10,y:6},{x:11,y:6},{x:12,y:6},{x:13,y:6},{x:14,y:6},
                {x:14,y:7},{x:14,y:8},{x:13,y:8},{x:12,y:8},{x:11,y:8},{x:10,y:8},{x:9,y:8}, {x:8,y:9},{x:8,y:10},{x:8,y:11},{x:8,y:12},{x:8,y:13},{x:8,y:14},
                {x:7,y:14},{x:6,y:14} 
            ];
            const offset = pid * 13;
            let path = [];
            for(let i=0; i<51; i++) path.push(perimeter[(i + offset) % 52]);
            if(pid===0) path.push({x:7,y:13},{x:7,y:12},{x:7,y:11},{x:7,y:10},{x:7,y:9},{x:7,y:8});
            if(pid===1) path.push({x:1,y:7},{x:2,y:7},{x:3,y:7},{x:4,y:7},{x:5,y:7},{x:6,y:7});
            if(pid===2) path.push({x:7,y:1},{x:7,y:2},{x:7,y:3},{x:7,y:4},{x:7,y:5},{x:7,y:6});
            if(pid===3) path.push({x:13,y:7},{x:12,y:7},{x:11,y:7},{x:10,y:7},{x:9,y:7},{x:8,y:7});
            return path;
        };
        const PATHS = [getPath(0), getPath(1), getPath(2), getPath(3)];
        const YARDS = [
            [{x:1,y:13}, {x:4,y:13}, {x:1,y:10}, {x:4,y:10}], 
            [{x:1,y:1}, {x:4,y:1}, {x:1,y:4}, {x:4,y:4}],     
            [{x:13,y:1}, {x:10,y:1}, {x:13,y:4}, {x:10,y:4}], 
            [{x:13,y:13}, {x:10,y:13}, {x:13,y:10}, {x:10,y:10}] 
        ];

        // --- INIT ---
        function init() {
            const cvs = document.getElementById('gameCanvas');
            renderer = new THREE.WebGLRenderer({ canvas: cvs, antialias: true, powerPreference: "high-performance" });
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // optimize for mobile
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x0f0c29, 0.03);
            
            camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 100);
            updateCameraForScreenSize();

            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const sun = new THREE.DirectionalLight(0xffffff, 0.8);
            sun.position.set(10, 20, 10);
            sun.castShadow = true;
            sun.shadow.mapSize.width = 1024; sun.shadow.mapSize.height = 1024;
            scene.add(sun);

            createBoard();
            createPieces();
            createStars();
            createEnvironment();
            
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            window.addEventListener('resize', onResize);
            window.addEventListener('touchstart', onPieceClick, {passive: false});
            window.addEventListener('mousedown', onPieceClick);
            
            // Start Button Handler
            document.getElementById('startBtn').addEventListener('click', () => {
                if(!audioCtx) audioCtx = new AudioCtx();
                if(audioCtx.state === 'suspended') audioCtx.resume();
                
                synth.click();
                
                document.getElementById('landing-screen').style.opacity = 0;
                document.getElementById('ui-layer').style.opacity = 1;
                setTimeout(() => {
                    document.getElementById('landing-screen').style.display = 'none';
                    gameState = 'TURN_START';
                    currentPlayer = 0;
                    startTurn();
                }, 500);
            });

            drawDiceFace(6);
            animate();
        }

        function updateCameraForScreenSize() {
            // Responsive Camera Logic
            const isMobile = window.innerWidth < 768;
            const aspect = window.innerWidth / window.innerHeight;
            
            if(isMobile) {
                // Pull back further on mobile to fit the board width
                const zoomFactor = aspect < 0.6 ? 38 : 30; // Tall phones need more height
                camera.position.set(0, zoomFactor, 20); 
            } else {
                camera.position.set(0, 22, 15);
            }
            camera.lookAt(0,0,0);
        }

        function createEnvironment() {
            const geo = new THREE.BufferGeometry();
            const pos = [];
            for(let i=0; i<600; i++) {
                pos.push((Math.random()-0.5)*80, Math.random()*40, (Math.random()-0.5)*80);
            }
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            const mat = new THREE.PointsMaterial({color:0xffffff, size:0.15, transparent:true, opacity:0.6});
            scene.add(new THREE.Points(geo, mat));
        }

        function createBoard() {
            boardGroup = new THREE.Group();
            const base = new THREE.Mesh(new THREE.BoxGeometry(16, 0.5, 16), new THREE.MeshStandardMaterial({color: 0x1a1a1a}));
            base.position.y = -0.25; base.receiveShadow = true;
            boardGroup.add(base);

            const cellGeo = new THREE.BoxGeometry(0.95, 0.1, 0.95);
            const whiteMat = new THREE.MeshStandardMaterial({color: 0xffffff});

            const createCell = (x, y, color) => {
                const mesh = new THREE.Mesh(cellGeo, color ? new THREE.MeshStandardMaterial({color}) : whiteMat);
                mesh.position.set(x - 7, 0.05, y - 7);
                mesh.receiveShadow = true;
                boardGroup.add(mesh);
            };

            for(let x=0; x<15; x++) {
                for(let y=0; y<15; y++) {
                    if(x<6 && y>=9) { createCell(x,y, COLORS[0]); continue; }
                    if(x<6 && y<6) { createCell(x,y, COLORS[1]); continue; }
                    if(x>=9 && y<6) { createCell(x,y, COLORS[2]); continue; }
                    if(x>=9 && y>=9) { createCell(x,y, COLORS[3]); continue; }
                    if(x>=6 && x<=8 && y>=6 && y<=8) {
                        if(!(x==7 && y==7)) createCell(x,y, 0xffd700);
                        continue;
                    }
                    let col = null;
                    if(x===7 && y>8 && y<14) col = COLORS[0];
                    if(y===7 && x>0 && x<6) col = COLORS[1];
                    if(x===7 && y>0 && y<6) col = COLORS[2];
                    if(y===7 && x>8 && x<14) col = COLORS[3];
                    if((x==6 && y==13) || (x==8 && y==1) || (x==1 && y==8) || (x==13 && y==6)) col = 0x888888;
                    if((x>=6 && x<=8) || (y>=6 && y<=8)) createCell(x,y, col);
                }
            }
            scene.add(boardGroup);
        }

        function createPieces() {
            const points = [];
            points.push(new THREE.Vector2(0,0));
            points.push(new THREE.Vector2(0.35,0));
            points.push(new THREE.Vector2(0.35,0.2));
            points.push(new THREE.Vector2(0.2,0.5));
            points.push(new THREE.Vector2(0,0.6));
            const geo = new THREE.LatheGeometry(points, 20);
            geo.translate(0,0,0);

            for(let p=0; p<4; p++) {
                pieces[p] = [];
                for(let i=0; i<4; i++) {
                    const mat = new THREE.MeshPhysicalMaterial({color: COLORS[p], metalness:0.3, roughness:0.2, clearcoat:1});
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.castShadow = true;
                    const ring = new THREE.Mesh(new THREE.RingGeometry(0.4, 0.5, 32), new THREE.MeshBasicMaterial({color: 0xffffff, transparent:true, opacity:0}));
                    ring.rotation.x = -Math.PI/2; ring.position.y = 0.02;
                    mesh.add(ring);
                    mesh.userData = { p: p, id: i, step: -1, ring: ring };
                    mesh.position.set(YARDS[p][i].x - 7, 0, YARDS[p][i].y - 7);
                    scene.add(mesh);
                    pieces[p].push(mesh);
                }
            }
        }

        function createStars() {
            const safes = [[6,13],[8,1],[1,8],[13,6],[8,12],[6,2],[2,6],[12,8]];
            safes.forEach(pos => {
                const star = new THREE.Mesh(new THREE.OctahedronGeometry(0.15), new THREE.MeshBasicMaterial({color: 0xffd700}));
                star.position.set(pos[0]-7, 0.3, pos[1]-7);
                scene.add(star);
                gsap.to(star.position, {y: 0.5, duration: 1, yoyo: true, repeat: -1});
                gsap.to(star.rotation, {y: Math.PI, duration: 2, repeat: -1, ease: "none"});
            });
        }

        // --- GAME LOGIC ---
        function startTurn() {
            gameState = 'TURN_START';
            document.querySelectorAll('.player-badge').forEach(b => b.classList.remove('active'));
            document.getElementById(`badge${currentPlayer}`).classList.add('active');
            
            focusCamera(currentPlayer);

            if(currentPlayer === 0) {
                setStatus("YOUR TURN");
                document.getElementById('dice-wrapper').classList.remove('disabled');
            } else {
                setStatus(`${NAMES[currentPlayer]}...`);
                document.getElementById('dice-wrapper').classList.add('disabled');
                setTimeout(aiRoll, 1000);
            }
        }

        function handleDiceClick() {
            if(currentPlayer !== 0 || gameState !== 'TURN_START') return;
            performRoll();
        }

        function aiRoll() { performRoll(); }

        function performRoll() {
            gameState = 'ROLLING';
            synth.roll();
            
            // CSS Animation trigger
            const diceDiv = document.getElementById('dice-wrapper');
            diceDiv.classList.add('rolling-anim');
            
            // Internal value shuffle
            let frames = 0;
            const anim = setInterval(() => {
                drawDiceFace(Math.ceil(Math.random()*6), true);
                frames++;
                if(frames > 12) {
                    clearInterval(anim);
                    diceDiv.classList.remove('rolling-anim');
                    finalizeRoll();
                }
            }, 60);
        }

        function finalizeRoll() {
            diceValue = Math.ceil(Math.random() * 6);
            drawDiceFace(diceValue, false);
            
            validMoves = getValidMoves(currentPlayer, diceValue);
            
            if(validMoves.length === 0) {
                setStatus(`NO MOVES`);
                setTimeout(endTurn, 1000);
            } else {
                if(currentPlayer === 0) {
                    gameState = 'WAITING_INPUT';
                    setStatus(`TAP PIECE`);
                    highlightPieces(true);
                    if(validMoves.length === 1 && validMoves[0].userData.step !== -1) movePiece(validMoves[0]);
                } else {
                    gameState = 'AI_THINKING';
                    setTimeout(aiDecide, 800);
                }
            }
        }

        function aiDecide() {
            // Priority: Kill > Home > Out > Advance
            let best = validMoves[0];
            let maxScore = -100;
            
            validMoves.forEach(p => {
                let score = Math.random() * 10;
                if(p.userData.step === -1) score += 50; // Get out
                else {
                    const dest = p.userData.step + diceValue;
                    if(dest >= PATHS[currentPlayer].length-1) score += 100; // Finish
                    // Simple kill check
                    const path = PATHS[currentPlayer];
                    const grid = path[dest];
                    if(grid) {
                        const px = grid.x, py = grid.y;
                        const safe = (px==6&&py==13)||(px==8&&py==1)||(px==1&&py==8)||(px==13&&py==6);
                        if(!safe) {
                           // Check collision with others (simplified)
                        }
                    }
                    score += dest; // Advance
                }
                if(score > maxScore) { maxScore = score; best = p; }
            });
            movePiece(best);
        }

        function movePiece(piece) {
            gameState = 'MOVING';
            highlightPieces(false);
            
            let cur = piece.userData.step;
            let target = cur + diceValue;
            let path = PATHS[currentPlayer];

            if(cur === -1) {
                jumpPiece(piece, path[0].x, path[0].y, () => {
                    piece.userData.step = 0;
                    checkTurnEnd(true); 
                });
            } else {
                // Multi-step anim
                let step = 1;
                const doStep = () => {
                    if(step <= diceValue) {
                        const next = path[cur + step];
                        if(!next) { checkTurnEnd(false); return; }
                        jumpPiece(piece, next.x, next.y, () => {
                            step++;
                            if(step > diceValue) {
                                piece.userData.step = target;
                                handleLanding(piece);
                            } else doStep();
                        });
                    }
                };
                doStep();
            }
        }

        function jumpPiece(piece, tx, ty, onComplete) {
            synth.move();
            const tl = gsap.timeline({onComplete: onComplete});
            tl.to(piece.position, { x: tx-7, z: ty-7, duration: 0.2, ease: "linear" }, 0);
            tl.to(piece.position, { y: 1.5, duration: 0.1, yoyo: true, repeat: 1, ease: "power1.out" }, 0);
        }

        function handleLanding(piece) {
            if(piece.userData.step >= PATHS[currentPlayer].length - 1) {
                synth.win();
                updateBadgeDots(currentPlayer);
                if(pieces[currentPlayer].every(p => p.userData.step >= PATHS[currentPlayer].length - 1)) {
                    document.getElementById('winner-name').innerText = `${NAMES[currentPlayer]} WINS!`;
                    document.getElementById('win-modal').style.display = 'flex';
                    return;
                }
                checkTurnEnd(true); return;
            }

            const px = Math.round(piece.position.x + 7);
            const py = Math.round(piece.position.z + 7);
            const isSafe = (px==6&&py==13)||(px==8&&py==1)||(px==1&&py==8)||(px==13&&py==6)||(px==8&&py==12)||(px==6&&py==2)||(px==2&&py==6)||(px==12&&py==8);
            
            let captured = false;
            if(!isSafe) {
                for(let op=0; op<4; op++) {
                    if(op === currentPlayer) continue;
                    pieces[op].forEach(en => {
                        const ex = Math.round(en.position.x + 7);
                        const ey = Math.round(en.position.z + 7);
                        if(ex === px && ey === py && en.userData.step !== -1) {
                            captureAnim(en); captured = true;
                        }
                    });
                }
            }
            
            if(captured) {
                setStatus("CAPTURE! BONUS!");
                setTimeout(() => checkTurnEnd(true), 1000);
            } else {
                checkTurnEnd(diceValue === 6);
            }
        }

        function captureAnim(piece) {
            synth.kill();
            piece.userData.step = -1;
            const h = YARDS[piece.userData.p][piece.userData.id];
            gsap.to(piece.position, {x: h.x-7, z: h.y-7, y: 5, duration: 0.6, ease: "back.in(1.7)", onComplete: ()=>piece.position.y=0});
        }

        function checkTurnEnd(bonus) {
            if(bonus) { gameState = 'TURN_START'; startTurn(); }
            else endTurn();
        }

        function endTurn() {
            currentPlayer = (currentPlayer + 1) % 4;
            startTurn();
        }

        function getValidMoves(pid, roll) {
            let res = [];
            pieces[pid].forEach(p => {
                if(p.userData.step === -1) { if(roll === 6) res.push(p); }
                else if(p.userData.step + roll < PATHS[pid].length) res.push(p);
            });
            return res;
        }

        function highlightPieces(on) {
            validMoves.forEach(p => {
                p.userData.ring.material.opacity = on ? 1 : 0;
                if(on) gsap.to(p.position, {y: 0.5, duration: 0.5, yoyo: true, repeat: -1, overwrite: true});
                else { gsap.killTweensOf(p.position); p.position.y = 0; }
            });
        }

        function updateBadgeDots(pid) {
            const el = document.getElementById(`dots${pid}`);
            el.innerHTML = '';
            const c = pieces[pid].filter(p => p.userData.step >= PATHS[pid].length - 1).length;
            for(let i=0; i<4; i++) {
                const d = document.createElement('div');
                d.className = 'dot' + (i<c ? ' home' : '');
                el.appendChild(d);
            }
        }

        function setStatus(text) {
            const el = document.getElementById('status-text');
            el.textContent = text;
            el.style.borderColor = HEX_STRINGS[currentPlayer];
            el.classList.add('show');
        }

        function focusCamera(pid) {
            const isMobile = window.innerWidth < 768;
            const yHeight = isMobile ? 38 : 22; // Keep mobile zoomed out
            const dist = isMobile ? 10 : 18;
            
            const angles = [{x:0,z:dist}, {x:-dist,z:0}, {x:0,z:-dist}, {x:dist,z:0}];
            
            gsap.to(camera.position, {
                x: angles[pid].x, z: angles[pid].z, y: yHeight,
                duration: 1.5, ease: "power2.inOut",
                onUpdate: () => camera.lookAt(0,0,0)
            });
        }

        function drawDiceFace(n, blur) {
            const ctx = document.getElementById('dice-canvas').getContext('2d');
            ctx.canvas.width = 120; ctx.canvas.height = 120;
            
            ctx.fillStyle = blur ? '#ddd' : 'white';
            ctx.fillRect(0,0,120,120);
            ctx.fillStyle = HEX_STRINGS[currentPlayer];
            
            const dot = (x,y) => { ctx.beginPath(); ctx.arc(x,y,14,0,Math.PI*2); ctx.fill(); };
            const pos = {
                1: [[60,60]], 2: [[30,30],[90,90]], 3: [[30,30],[60,60],[90,90]],
                4: [[30,30],[90,30],[30,90],[90,90]], 5: [[30,30],[90,30],[60,60],[30,90],[90,90]],
                6: [[30,30],[90,30],[30,60],[90,60],[30,90],[90,90]]
            };
            if(pos[n]) pos[n].forEach(p => dot(p[0],p[1]));
        }

        function drawMinimap() {
            const ctx = document.getElementById('minimap-canvas').getContext('2d');
            ctx.fillStyle = '#1a1a1a'; ctx.fillRect(0,0,100,100);
            
            pieces.forEach(row => row.forEach(p => {
                if(p.userData.step >= PATHS[p.userData.p].length-1) return;
                const x = ((p.position.x+7)/14)*80 + 10;
                const y = ((p.position.z+7)/14)*80 + 10;
                ctx.fillStyle = HEX_STRINGS[p.userData.p];
                ctx.beginPath(); ctx.arc(x,y,3,0,Math.PI*2); ctx.fill();
            }));
        }

        function onPieceClick(e) {
            if(gameState !== 'WAITING_INPUT' || currentPlayer !== 0) return;
            e.preventDefault();
            
            const cx = e.touches ? e.touches[0].clientX : e.clientX;
            const cy = e.touches ? e.touches[0].clientY : e.clientY;
            
            mouse.x = (cx / window.innerWidth) * 2 - 1;
            mouse.y = -(cy / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(pieces[0]);
            
            if(intersects.length > 0) {
                const p = intersects[0].object;
                if(validMoves.includes(p)) movePiece(p);
            }
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            updateCameraForScreenSize();
        }

        function toggleSound() {
            soundEnabled = !soundEnabled;
            document.getElementById('soundIcon').className = soundEnabled ? "fas fa-volume-up" : "fas fa-volume-mute";
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
            drawMinimap();
            
            if(gameState === 'MENU') {
                orbitAngle += 0.002;
                camera.position.x = Math.sin(orbitAngle) * 30;
                camera.position.z = Math.cos(orbitAngle) * 30;
                camera.position.y = 20;
                camera.lookAt(0,0,0);
            }
        }

        init();
    </script>
</body>
</html>

