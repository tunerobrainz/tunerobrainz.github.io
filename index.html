
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ludo 3D - Contest Edition</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Outfit:wght@300;500;700;900&display=swap');
        
        :root {
            --red: #ff4757; --green: #2ed573; --yellow: #ffa502; --blue: #1e90ff;
            --glass-bg: rgba(15, 23, 42, 0.6);
            --glass-border: rgba(255, 255, 255, 0.15);
        }

        * { margin:0; padding:0; box-sizing:border-box; user-select:none; -webkit-tap-highlight-color:transparent; font-family:'Outfit', sans-serif; }
        
        body { 
            overflow:hidden; background: #0f0c29; color: white;
            height: 100vh; width: 100vw;
        }

        #gameCanvas { position: fixed; top: 0; left: 0; z-index: 1; outline: none; }

        /* UI Layer */
        #ui-layer {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
        }

        .glass-panel {
            background: var(--glass-bg);
            backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--glass-border);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
            border-radius: 16px; pointer-events: auto;
        }

        /* Top HUD */
        #top-bar { padding: 15px; display: flex; justify-content: space-between; align-items: flex-start; }
        
        /* MiniMap */
        #minimap-container {
            width: 140px; height: 140px; padding: 10px;
            display: flex; flex-direction: column; align-items: center;
        }
        #minimap-canvas { width: 100%; height: 100%; border-radius: 8px; opacity: 0.9; }

        /* Player Badges */
        .badges-container { display: flex; gap: 8px; position: absolute; top: 15px; left: 50%; transform: translateX(-50%); }
        .player-badge {
            display: flex; flex-direction: column; align-items: center;
            padding: 8px 12px; background: rgba(0,0,0,0.5); border-radius: 12px;
            transition: all 0.3s; border: 2px solid transparent;
            min-width: 60px;
        }
        .player-badge.active { transform: scale(1.15); box-shadow: 0 0 15px rgba(255,255,255,0.2); }
        .player-badge.active[data-p="0"] { border-color: var(--red); background: rgba(255, 71, 87, 0.2); }
        .player-badge.active[data-p="1"] { border-color: var(--green); background: rgba(46, 213, 115, 0.2); }
        .player-badge.active[data-p="2"] { border-color: var(--yellow); background: rgba(255, 165, 2, 0.2); }
        .player-badge.active[data-p="3"] { border-color: var(--blue); background: rgba(30, 144, 255, 0.2); }
        
        .p-icon { font-size: 1.2rem; margin-bottom: 4px; }
        .p-dots { display: flex; gap: 3px; }
        .dot { width: 6px; height: 6px; border-radius: 50%; background: #444; }
        .dot.home { background: #ffd700; box-shadow: 0 0 5px #ffd700; }

        /* Controls */
        #controls {
            position: absolute; bottom: 30px; width: 100%;
            display: flex; justify-content: center; align-items: flex-end;
            pointer-events: none;
        }

        #dice-wrapper {
            position: relative; width: 120px; height: 120px;
            pointer-events: auto; transition: transform 0.2s;
        }
        #dice-wrapper.disabled { filter: grayscale(1); pointer-events: none; opacity: 0.7; }
        #dice-wrapper:active { transform: scale(0.95); }
        #dice-canvas { width: 100%; height: 100%; border-radius: 24px; }
        
        #status-text {
            position: absolute; bottom: 160px; left: 50%; transform: translateX(-50%);
            padding: 10px 25px; border-radius: 50px;
            font-weight: 800; font-size: 1.2rem; letter-spacing: 1px;
            text-align: center; white-space: nowrap;
            opacity: 0; transition: opacity 0.3s;
            border: 1px solid rgba(255,255,255,0.3);
            text-shadow: 0 2px 4px rgba(0,0,0,0.5);
        }
        #status-text.show { opacity: 1; }

        /* Welcome Screen */
        #landing-screen {
            position: fixed; top:0; left:0; width:100%; height:100%;
            background: rgba(15, 12, 41, 0.95); z-index: 100;
            display: flex; justify-content: center; align-items: center;
        }
        .welcome-card { text-align: center; padding: 40px; max-width: 500px; width: 90%; }
        .game-title { 
            font-size: 3rem; font-weight: 900; margin-bottom: 20px; 
            background: linear-gradient(45deg, #ff4757, #ffa502); 
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }
        .btn-start {
            background: linear-gradient(135deg, #6C63FF, #4834d4);
            color: white; border: none; padding: 15px 40px;
            font-size: 1.2rem; font-weight: 700; border-radius: 50px;
            cursor: pointer; margin-top: 20px;
            box-shadow: 0 0 20px rgba(108, 99, 255, 0.4);
        }

        /* Winner Modal */
        #win-modal {
            position: fixed; top:0; left:0; width:100%; height:100%;
            background: rgba(0,0,0,0.95); display: none; z-index: 200;
            flex-direction: column; justify-content: center; align-items: center;
        }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div id="top-bar">
            <div id="minimap-container" class="glass-panel">
                <span style="font-size:10px; opacity:0.7; margin-bottom:5px;">MINIMAP</span>
                <canvas id="minimap-canvas" width="120" height="120"></canvas>
            </div>
            
            <div class="fab glass-panel" style="width:40px; height:40px; display:flex; justify-content:center; align-items:center; border-radius:50%; cursor:pointer;" onclick="toggleSound()">
                <i id="soundIcon" class="fas fa-volume-up"></i>
            </div>
        </div>

        <div class="badges-container">
            <div class="player-badge active" id="badge0" data-p="0"><i class="fas fa-user p-icon" style="color:var(--red)"></i><div class="p-dots" id="dots0"></div></div>
            <div class="player-badge" id="badge1" data-p="1"><i class="fas fa-robot p-icon" style="color:var(--green)"></i><div class="p-dots" id="dots1"></div></div>
            <div class="player-badge" id="badge2" data-p="2"><i class="fas fa-robot p-icon" style="color:var(--yellow)"></i><div class="p-dots" id="dots2"></div></div>
            <div class="player-badge" id="badge3" data-p="3"><i class="fas fa-robot p-icon" style="color:var(--blue)"></i><div class="p-dots" id="dots3"></div></div>
        </div>

        <div id="status-text" class="glass-panel">YOUR TURN</div>

        <div id="controls">
            <div id="dice-wrapper" class="glass-panel" onclick="handleDiceClick()">
                <canvas id="dice-canvas"></canvas>
            </div>
        </div>
    </div>

    <div id="landing-screen">
        <div class="welcome-card glass-panel">
            <h1 class="game-title">LUDO 3D</h1>
            <p style="margin-bottom:20px; opacity:0.8;">Contest Edition â€¢ AI Enabled</p>
            <div style="text-align:left; background:rgba(255,255,255,0.05); padding:15px; border-radius:10px; margin-bottom:20px; font-size:0.9rem;">
                <div style="margin-bottom:8px;"><i class="fas fa-user" style="color:var(--red); width:20px;"></i> <b>You are Red</b></div>
                <div style="margin-bottom:8px;"><i class="fas fa-dice" style="color:white; width:20px;"></i> Roll <b>6</b> to start or get bonus turn</div>
                <div style="margin-bottom:8px;"><i class="fas fa-star" style="color:#ffd700; width:20px;"></i> Stars are Safe Zones</div>
                <div><i class="fas fa-skull" style="color:var(--red); width:20px;"></i> Capture enemies to win fast!</div>
            </div>
            <button class="btn-start" onclick="startGame()">START GAME</button>
        </div>
    </div>

    <div id="win-modal">
        <i class="fas fa-trophy" style="font-size:5rem; color:#ffd700; margin-bottom:20px;"></i>
        <h1 class="game-title" id="winner-name">RED WINS!</h1>
        <button class="btn-start" onclick="location.reload()">PLAY AGAIN</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <script>
        // --- CONSTANTS ---
        const COLORS = [0xff4757, 0x2ed573, 0xffa502, 0x1e90ff];
        const HEX_STRINGS = ['#ff4757', '#2ed573', '#ffa502', '#1e90ff'];
        const NAMES = ['YOU', 'CPU GREEN', 'CPU YELLOW', 'CPU BLUE'];
        
        // --- GAME STATE ---
        let scene, camera, renderer, raycaster, mouse;
        let pieces = [], boardGroup;
        let currentPlayer = 0; // 0=Human, 1,2,3=AI
        let gameState = 'MENU'; // MENU, TURN_START, ROLLING, WAITING_INPUT, MOVING, AI_THINKING
        let diceValue = 1;
        let soundEnabled = true;
        let validMoves = [];
        let particles = [];

        // --- AUDIO ---
        const AudioCtx = window.AudioContext || window.webkitAudioContext;
        let audioCtx;
        const synth = {
            play: (freq, type, dur, vol=0.1) => {
                if(!soundEnabled || !audioCtx) return;
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
                gain.gain.setValueAtTime(vol, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + dur);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + dur);
            },
            roll: () => { for(let i=0;i<6;i++) setTimeout(()=>synth.play(200+Math.random()*300,'square',0.05), i*50); },
            move: () => synth.play(400,'sine',0.1),
            kill: () => { synth.play(150,'sawtooth',0.3); setTimeout(()=>synth.play(100,'sawtooth',0.4),100); },
            win: () => [523,659,784,1047].forEach((f,i)=>setTimeout(()=>synth.play(f,'square',0.4),i*150))
        };

        // --- PATH LOGIC (15x15 Grid) ---
        // 0-14 coordinates. Center is 7,7.
        // Fixed Path Logic to ensure correct routing
        const getPath = (pid) => {
            const perimeter = [
                {x:6,y:13},{x:6,y:12},{x:6,y:11},{x:6,y:10},{x:6,y:9}, {x:5,y:8},{x:4,y:8},{x:3,y:8},{x:2,y:8},{x:1,y:8},{x:0,y:8},
                {x:0,y:7},{x:0,y:6},{x:1,y:6},{x:2,y:6},{x:3,y:6},{x:4,y:6},{x:5,y:6}, {x:6,y:5},{x:6,y:4},{x:6,y:3},{x:6,y:2},{x:6,y:1},{x:6,y:0},
                {x:7,y:0},{x:8,y:0},{x:8,y:1},{x:8,y:2},{x:8,y:3},{x:8,y:4},{x:8,y:5}, {x:9,y:6},{x:10,y:6},{x:11,y:6},{x:12,y:6},{x:13,y:6},{x:14,y:6},
                {x:14,y:7},{x:14,y:8},{x:13,y:8},{x:12,y:8},{x:11,y:8},{x:10,y:8},{x:9,y:8}, {x:8,y:9},{x:8,y:10},{x:8,y:11},{x:8,y:12},{x:8,y:13},{x:8,y:14},
                {x:7,y:14},{x:6,y:14} 
            ];
            const offset = pid * 13;
            let path = [];
            for(let i=0; i<51; i++) path.push(perimeter[(i + offset) % 52]);
            // Home run
            if(pid===0) path.push({x:7,y:13},{x:7,y:12},{x:7,y:11},{x:7,y:10},{x:7,y:9},{x:7,y:8});
            if(pid===1) path.push({x:1,y:7},{x:2,y:7},{x:3,y:7},{x:4,y:7},{x:5,y:7},{x:6,y:7});
            if(pid===2) path.push({x:7,y:1},{x:7,y:2},{x:7,y:3},{x:7,y:4},{x:7,y:5},{x:7,y:6});
            if(pid===3) path.push({x:13,y:7},{x:12,y:7},{x:11,y:7},{x:10,y:7},{x:9,y:7},{x:8,y:7});
            return path;
        };
        const PATHS = [getPath(0), getPath(1), getPath(2), getPath(3)];

        // FIXED YARD COORDINATES (Integers for perfect centering)
        const YARDS = [
            [{x:1,y:13}, {x:4,y:13}, {x:1,y:10}, {x:4,y:10}], // Red (Bottom-Left in visual, depends on camera)
            [{x:1,y:1}, {x:4,y:1}, {x:1,y:4}, {x:4,y:4}],     // Green (Top-Left)
            [{x:13,y:1}, {x:10,y:1}, {x:13,y:4}, {x:10,y:4}], // Yellow (Top-Right)
            [{x:13,y:13}, {x:10,y:13}, {x:13,y:10}, {x:10,y:10}] // Blue (Bottom-Right)
        ];
        // Note: Ludo boards vary, but typically Red is bottom-left (0,0 to 5,5 area).
        // My coordinate system (x right, y down/z down):
        // 0,0 is Top-Left visually. 
        // Let's stick to the visual coloring:
        // Red Yard: 0-5 x, 9-14 y (Bottom Left) -> Correct in YARDS[0]
        // Green Yard: 0-5 x, 0-5 y (Top Left) -> Correct in YARDS[1]
        // Yellow Yard: 9-14 x, 0-5 y (Top Right) -> Correct in YARDS[2]
        // Blue Yard: 9-14 x, 9-14 y (Bottom Right) -> Correct in YARDS[3]

        // --- INITIALIZATION ---
        function init() {
            const cvs = document.getElementById('gameCanvas');
            renderer = new THREE.WebGLRenderer({ canvas: cvs, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x0f0c29, 0.035);
            
            camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 100);
            camera.position.set(0, 20, 15);
            camera.lookAt(0,0,0);

            // Lights
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const sun = new THREE.DirectionalLight(0xffffff, 0.8);
            sun.position.set(10, 20, 10);
            sun.castShadow = true;
            sun.shadow.mapSize.width = 2048; sun.shadow.mapSize.height = 2048;
            scene.add(sun);

            createBoard();
            createPieces();
            createStars();
            
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            window.addEventListener('resize', onResize);
            window.addEventListener('mousedown', onPieceClick);
            
            drawDiceFace(6);
            animate();
        }

        function createBoard() {
            boardGroup = new THREE.Group();
            
            // Main Base
            const base = new THREE.Mesh(
                new THREE.BoxGeometry(16, 0.5, 16),
                new THREE.MeshStandardMaterial({color: 0x1a1a1a})
            );
            base.position.y = -0.25;
            base.receiveShadow = true;
            boardGroup.add(base);

            const cellGeo = new THREE.BoxGeometry(0.95, 0.1, 0.95);
            const whiteMat = new THREE.MeshStandardMaterial({color: 0xffffff});

            const createCell = (x, y, color) => {
                const mesh = new THREE.Mesh(cellGeo, color ? new THREE.MeshStandardMaterial({color}) : whiteMat);
                // Center mapping: x=0 -> -7, x=14 -> 7. x=7 -> 0.
                mesh.position.set(x - 7, 0.05, y - 7);
                mesh.receiveShadow = true;
                boardGroup.add(mesh);
            };

            for(let x=0; x<15; x++) {
                for(let y=0; y<15; y++) {
                    // Yards
                    if(x<6 && y>=9) { createCell(x,y, COLORS[0]); continue; }
                    if(x<6 && y<6) { createCell(x,y, COLORS[1]); continue; }
                    if(x>=9 && y<6) { createCell(x,y, COLORS[2]); continue; }
                    if(x>=9 && y>=9) { createCell(x,y, COLORS[3]); continue; }
                    
                    // Center
                    if(x>=6 && x<=8 && y>=6 && y<=8) {
                        if(x==7 && y==7) { /* Center hole, skip or add gold */ }
                        else createCell(x,y, 0xffd700); // Home triangle area
                        continue;
                    }

                    // Paths
                    let col = null;
                    if(x===7 && y>8 && y<14) col = COLORS[0];
                    if(y===7 && x>0 && x<6) col = COLORS[1];
                    if(x===7 && y>0 && y<6) col = COLORS[2];
                    if(y===7 && x>8 && x<14) col = COLORS[3];
                    
                    // Safe Spots (Grey or Color)
                    const isSafe = (x==6 && y==13) || (x==8 && y==1) || (x==1 && y==8) || (x==13 && y==6);
                    if(isSafe) col = 0x888888;
                    
                    if((x>=6 && x<=8) || (y>=6 && y<=8)) createCell(x,y, col);
                }
            }
            scene.add(boardGroup);
        }

        function createPieces() {
            // Ludo Seed Shape (Rounded Dome)
            const points = [];
            points.push(new THREE.Vector2(0,0));
            points.push(new THREE.Vector2(0.35,0));
            points.push(new THREE.Vector2(0.35,0.2));
            points.push(new THREE.Vector2(0.2,0.5));
            points.push(new THREE.Vector2(0,0.6));
            const geo = new THREE.LatheGeometry(points, 20);
            geo.translate(0,0,0);

            for(let p=0; p<4; p++) {
                pieces[p] = [];
                for(let i=0; i<4; i++) {
                    const mat = new THREE.MeshPhysicalMaterial({
                        color: COLORS[p], metalness:0.3, roughness:0.2, clearcoat:1
                    });
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.castShadow = true;
                    
                    // Selection Ring
                    const ring = new THREE.Mesh(
                        new THREE.RingGeometry(0.4, 0.5, 32),
                        new THREE.MeshBasicMaterial({color: 0xffffff, transparent:true, opacity:0})
                    );
                    ring.rotation.x = -Math.PI/2;
                    ring.position.y = 0.02;
                    mesh.add(ring);
                    
                    mesh.userData = { p: p, id: i, step: -1, ring: ring };
                    setPiecePos(mesh, YARDS[p][i].x, YARDS[p][i].y);
                    scene.add(mesh);
                    pieces[p].push(mesh);
                }
            }
        }

        function createStars() {
            const safes = [[6,13],[8,1],[1,8],[13,6],[8,12],[6,2],[2,6],[12,8]];
            safes.forEach(pos => {
                const star = new THREE.Mesh(
                    new THREE.OctahedronGeometry(0.15),
                    new THREE.MeshBasicMaterial({color: 0xffd700})
                );
                star.position.set(pos[0]-7, 0.3, pos[1]-7);
                scene.add(star);
                // Simple pulse anim
                gsap.to(star.position, {y: 0.5, duration: 1, yoyo: true, repeat: -1});
                gsap.to(star.rotation, {y: Math.PI, duration: 2, repeat: -1, ease: "none"});
            });
        }

        function setPiecePos(mesh, x, y) {
            // Perfectly centered on the square
            mesh.position.set(x - 7, 0, y - 7);
        }

        // --- LOGIC ---
        function startGame() {
            if(!audioCtx) audioCtx = new AudioCtx();
            document.getElementById('landing-screen').style.display = 'none';
            currentPlayer = 0;
            startTurn();
        }

        function startTurn() {
            gameState = 'TURN_START';
            updateUI();
            
            // Camera focus
            focusCamera(currentPlayer);

            if(currentPlayer === 0) {
                // Human
                setStatus("YOUR TURN - ROLL!");
                document.getElementById('dice-wrapper').classList.remove('disabled');
            } else {
                // AI
                setStatus(`${NAMES[currentPlayer]} THINKING...`);
                document.getElementById('dice-wrapper').classList.add('disabled');
                setTimeout(aiRoll, 1000);
            }
        }

        function handleDiceClick() {
            if(currentPlayer !== 0 || gameState !== 'TURN_START') return;
            performRoll();
        }

        function aiRoll() {
            performRoll();
        }

        function performRoll() {
            gameState = 'ROLLING';
            synth.roll();
            
            let frames = 0;
            const anim = setInterval(() => {
                drawDiceFace(Math.ceil(Math.random()*6), true);
                frames++;
                if(frames > 15) {
                    clearInterval(anim);
                    finalizeRoll();
                }
            }, 60);
        }

        function finalizeRoll() {
            diceValue = Math.ceil(Math.random() * 6);
            // DEBUG: Uncomment to force 6
            // diceValue = 6; 
            drawDiceFace(diceValue, false);
            
            validMoves = getValidMoves(currentPlayer, diceValue);
            
            if(validMoves.length === 0) {
                setStatus(`ROLLED ${diceValue} - NO MOVES`);
                setTimeout(endTurn, 1500);
            } else {
                if(currentPlayer === 0) {
                    // Human Input
                    gameState = 'WAITING_INPUT';
                    setStatus(`ROLLED ${diceValue} - TAP PIECE`);
                    highlightPieces(true);
                    // Auto move if only 1 choice and it's a board move (not yard out)
                    if(validMoves.length === 1 && validMoves[0].userData.step !== -1) {
                        movePiece(validMoves[0]);
                    }
                } else {
                    // AI Decision
                    gameState = 'AI_THINKING';
                    setTimeout(aiDecide, 800);
                }
            }
        }

        function aiDecide() {
            // Simple Heuristic: Kill > Out > Home > Furthest
            let bestPiece = validMoves[0];
            let bestScore = -100;

            validMoves.forEach(p => {
                let score = 0;
                // Move out of yard is good
                if(p.userData.step === -1) score += 50;
                else {
                    const destStep = p.userData.step + diceValue;
                    // Check kill (simplified)
                    // (Real collision logic needed here for perfect AI, but random is okay for Ludo chaos)
                    score += destStep; // Advance is good
                    if(destStep >= PATHS[currentPlayer].length-1) score += 100; // Finish is best
                }
                
                // Add randomness so AI isn't robotic
                score += Math.random() * 20;

                if(score > bestScore) {
                    bestScore = score;
                    bestPiece = p;
                }
            });

            movePiece(bestPiece);
        }

        function movePiece(piece) {
            gameState = 'MOVING';
            highlightPieces(false);
            
            let currentPathIdx = piece.userData.step;
            let targetPathIdx;
            let path = PATHS[currentPlayer];

            if(currentPathIdx === -1) {
                // Yard to Board
                targetPathIdx = 0;
                jumpPiece(piece, path[0].x, path[0].y, () => {
                    piece.userData.step = 0;
                    checkTurnEnd(true); // Bonus roll for 6
                });
            } else {
                // Board Move
                targetPathIdx = currentPathIdx + diceValue;
                
                // Step-by-step animation
                let step = 1;
                const doStep = () => {
                    if(step <= diceValue) {
                        const nextGrid = path[currentPathIdx + step];
                        if(!nextGrid) { // Overflow protection
                             checkTurnEnd(false); return; 
                        }
                        jumpPiece(piece, nextGrid.x, nextGrid.y, () => {
                            step++;
                            if(step > diceValue) {
                                // Done moving
                                piece.userData.step = targetPathIdx;
                                handleLanding(piece);
                            } else {
                                doStep();
                            }
                        });
                    }
                };
                doStep();
            }
        }

        function jumpPiece(piece, tx, ty, onComplete) {
            synth.move();
            const tl = gsap.timeline({onComplete: onComplete});
            tl.to(piece.position, { x: tx-7, z: ty-7, duration: 0.25, ease: "linear" }, 0);
            tl.to(piece.position, { y: 1.5, duration: 0.125, yoyo: true, repeat: 1, ease: "power1.out" }, 0);
        }

        function handleLanding(piece) {
            // Check Win
            if(piece.userData.step >= PATHS[currentPlayer].length - 1) {
                synth.win();
                updateBadgeDots(currentPlayer);
                // Check Total Win
                if(pieces[currentPlayer].every(p => p.userData.step >= PATHS[currentPlayer].length - 1)) {
                    document.getElementById('winner-name').innerText = `${NAMES[currentPlayer]} WINS!`;
                    document.getElementById('win-modal').style.display = 'flex';
                    return;
                }
                checkTurnEnd(true); // Bonus for home? Usually no, but let's give bonus for goal
                return;
            }

            // Check Capture
            const px = Math.round(piece.position.x + 7);
            const py = Math.round(piece.position.z + 7);
            
            // Is Safe?
            const isSafe = (px==6&&py==13)||(px==8&&py==1)||(px==1&&py==8)||(px==13&&py==6)||(px==8&&py==12)||(px==6&&py==2)||(px==2&&py==6)||(px==12&&py==8);
            
            let captured = false;
            if(!isSafe) {
                // Check enemies
                for(let otherP=0; otherP<4; otherP++) {
                    if(otherP === currentPlayer) continue;
                    pieces[otherP].forEach(enemy => {
                        const ex = Math.round(enemy.position.x + 7);
                        const ey = Math.round(enemy.position.z + 7);
                        if(ex === px && ey === py && enemy.userData.step !== -1) {
                            // KILL
                            captureAnim(enemy);
                            captured = true;
                        }
                    });
                }
            }

            if(captured) {
                setStatus("CAPTURE! BONUS ROLL!");
                setTimeout(() => checkTurnEnd(true), 1000);
            } else {
                checkTurnEnd(diceValue === 6);
            }
        }

        function captureAnim(piece) {
            synth.kill();
            piece.userData.step = -1;
            const home = YARDS[piece.userData.p][piece.userData.id];
            gsap.to(piece.position, {x: home.x-7, z: home.y-7, y: 5, duration: 0.6, ease: "back.in(1.7)", onComplete: () => {
                piece.position.y = 0;
            }});
        }

        function checkTurnEnd(bonus) {
            if(bonus) {
                gameState = 'TURN_START';
                startTurn(); // Same player
            } else {
                endTurn();
            }
        }

        function endTurn() {
            currentPlayer = (currentPlayer + 1) % 4;
            startTurn();
        }

        function getValidMoves(pid, roll) {
            let res = [];
            pieces[pid].forEach(p => {
                if(p.userData.step === -1) {
                    if(roll === 6) res.push(p);
                } else {
                    const pathLen = PATHS[pid].length;
                    if(p.userData.step + roll < pathLen) res.push(p);
                }
            });
            return res;
        }

        // --- VISUAL HELPERS ---
        function highlightPieces(on) {
            validMoves.forEach(p => {
                p.userData.ring.material.opacity = on ? 1 : 0;
                if(on) gsap.to(p.position, {y: 0.5, duration: 0.5, yoyo: true, repeat: -1, overwrite: true});
                else {
                    gsap.killTweensOf(p.position);
                    p.position.y = 0;
                }
            });
        }

        function updateBadgeDots(pid) {
            const container = document.getElementById(`dots${pid}`);
            container.innerHTML = '';
            const count = pieces[pid].filter(p => p.userData.step >= PATHS[pid].length - 1).length;
            for(let i=0; i<4; i++) {
                const d = document.createElement('div');
                d.className = 'dot' + (i<count ? ' home' : '');
                container.appendChild(d);
            }
        }

        function setStatus(text) {
            const el = document.getElementById('status-text');
            el.textContent = text;
            el.style.borderColor = HEX_STRINGS[currentPlayer];
            el.classList.add('show');
        }

        function updateUI() {
            document.querySelectorAll('.player-badge').forEach(b => b.classList.remove('active'));
            document.getElementById(`badge${currentPlayer}`).classList.add('active');
        }

        function focusCamera(pid) {
            // Dynamic Camera Angles based on player
            // Red: Look from bottom
            // Green: Look from Left
            const angles = [
                {x: 0, z: 18}, // Red
                {x: -18, z: 0}, // Green
                {x: 0, z: -18}, // Yellow
                {x: 18, z: 0}   // Blue
            ];
            gsap.to(camera.position, {
                x: angles[pid].x, z: angles[pid].z, y: 20, 
                duration: 1.5, ease: "power2.inOut",
                onUpdate: () => camera.lookAt(0,0,0)
            });
        }

        // --- MINIMAP ---
        const mmCanvas = document.getElementById('minimap-canvas');
        const mmCtx = mmCanvas.getContext('2d');
        
        function drawMinimap() {
            mmCtx.fillStyle = '#0f0c29';
            mmCtx.fillRect(0,0,120,120);
            
            // Draw Grid hint
            mmCtx.strokeStyle = '#333';
            mmCtx.lineWidth = 1;
            mmCtx.strokeRect(20,20,80,80); // inner
            
            // Draw Pieces
            pieces.forEach(row => {
                row.forEach(p => {
                    if(p.userData.step >= PATHS[p.userData.p].length-1) return; // Don't draw finished pieces
                    
                    // Map -7 to 7 range to 10 to 110 range
                    const mx = ((p.position.x + 7) / 14) * 100 + 10;
                    const my = ((p.position.z + 7) / 14) * 100 + 10;
                    
                    mmCtx.fillStyle = HEX_STRINGS[p.userData.p];
                    mmCtx.beginPath();
                    mmCtx.arc(mx, my, 4, 0, Math.PI*2);
                    mmCtx.fill();
                    
                    if(p.userData.p === currentPlayer) {
                        mmCtx.strokeStyle = 'white';
                        mmCtx.stroke();
                    }
                });
            });
        }

        // --- DICE CANVAS ---
        const diceCtx = document.getElementById('dice-canvas').getContext('2d');
        function drawDiceFace(n, blur=false) {
            const ctx = diceCtx;
            ctx.fillStyle = blur ? '#eee' : 'white';
            ctx.fillRect(0,0,300,150); // canvas defaults
            
            ctx.fillStyle = HEX_STRINGS[currentPlayer];
            const size = 300; // Actually canvas is small, handled by CSS
            // Simple dots
            // Cleared by fillRect
            const drawDot = (x,y) => {
                ctx.beginPath();
                ctx.arc(x, y, 15, 0, Math.PI*2);
                ctx.fill();
            }
            const cx=150, cy=75; // Canvas internal resolution is default 300x150 usually? 
            // Let's rely on CSS sizing, assumes 300x150 default internal
            
            // Reset to 120x120 internal matches CSS
            ctx.canvas.width = 120; ctx.canvas.height = 120;
            ctx.fillStyle = 'white';
            ctx.fillRect(0,0,120,120);
            ctx.fillStyle = HEX_STRINGS[currentPlayer];
            
            const pos = {
                1: [[60,60]],
                2: [[30,30],[90,90]],
                3: [[30,30],[60,60],[90,90]],
                4: [[30,30],[90,30],[30,90],[90,90]],
                5: [[30,30],[90,30],[60,60],[30,90],[90,90]],
                6: [[30,30],[90,30],[30,60],[90,60],[30,90],[90,90]]
            };
            pos[n].forEach(p => drawDot(p[0], p[1]));
        }

        // --- INPUT HANDLERS ---
        function onPieceClick(e) {
            if(gameState !== 'WAITING_INPUT' || currentPlayer !== 0) return;
            
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(pieces[0]); // Only Human pieces
            
            if(intersects.length > 0) {
                const clickedPiece = intersects[0].object;
                if(validMoves.includes(clickedPiece)) {
                    movePiece(clickedPiece);
                }
            }
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function toggleSound() {
            soundEnabled = !soundEnabled;
            document.getElementById('soundIcon').className = soundEnabled ? "fas fa-volume-up" : "fas fa-volume-mute";
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
            drawMinimap();
        }

        init();
    </script>
</body>
</html>

