<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Ludo Game - Premium Edition</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            position: fixed;
            width: 100%;
            height: 100%;
            touch-action: none;
        }

        #gameContainer {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #ui {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        #topBar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            pointer-events: auto;
            flex-wrap: wrap;
            gap: 10px;
        }

        .playerInfo {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 8px 12px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            border: 2px solid transparent;
            transition: all 0.3s;
            min-width: 100px;
            flex: 1;
        }

        @media (max-width: 768px) {
            .playerInfo {
                padding: 6px 8px;
                min-width: 80px;
            }
        }

        .playerInfo.active {
            border-color: #ffd700;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
        }

        .playerName {
            font-size: 14px;
            font-weight: bold;
            color: white;
            margin-bottom: 5px;
        }

        @media (max-width: 768px) {
            .playerName {
                font-size: 11px;
            }
        }

        .playerPieces {
            display: flex;
            gap: 5px;
        }

        .pieceIndicator {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            border: 1px solid white;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            pointer-events: auto;
            flex-wrap: wrap;
            justify-content: center;
            max-width: 90%;
        }

        @media (max-width: 768px) {
            #controls {
                bottom: 10px;
                gap: 8px;
            }
        }

        button {
            padding: 12px 20px;
            font-size: 14px;
            font-weight: bold;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
            touch-action: manipulation;
        }

        @media (max-width: 768px) {
            button {
                padding: 10px 16px;
                font-size: 12px;
            }
        }

        #rollButton {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            box-shadow: 0 5px 20px rgba(245, 87, 108, 0.4);
        }

        #rollButton:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(245, 87, 108, 0.6);
        }

        #rollButton:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #diceDisplay {
            position: absolute;
            top: 50%;
            right: 20px;
            transform: translateY(-50%);
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 20px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.3);
            pointer-events: auto;
            min-width: 150px;
        }

        @media (max-width: 768px) {
            #diceDisplay {
                right: 10px;
                padding: 15px;
                min-width: 120px;
            }
        }

        #diceCanvas {
            width: 120px;
            height: 120px;
            margin: 0 auto;
            display: block;
        }

        @media (max-width: 768px) {
            #diceCanvas {
                width: 100px;
                height: 100px;
            }
        }

        #diceLabel {
            text-align: center;
            color: white;
            font-size: 16px;
            font-weight: bold;
            margin-top: 10px;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.5);
        }

        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px 50px;
            border-radius: 15px;
            font-size: 24px;
            font-weight: bold;
            text-align: center;
            pointer-events: auto;
            display: none;
            animation: fadeIn 0.3s;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
            to { opacity: 1; transform: translate(-50%, -50%) scale(1); }
        }

        #rulesButton, #restartButton {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 2px solid white;
        }

        #rulesButton:hover, #restartButton:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        #rulesModal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 40px;
            border-radius: 20px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            display: none;
            pointer-events: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        }

        #rulesModal h2 {
            color: #667eea;
            margin-bottom: 20px;
        }

        #rulesModal ul {
            margin-left: 20px;
            line-height: 1.8;
        }

        #rulesModal li {
            margin-bottom: 10px;
        }

        #closeRules {
            margin-top: 20px;
            background: #667eea;
            color: white;
            width: 100%;
        }

        .winner-message {
            font-size: 36px;
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        #soundToggle {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid white;
            color: white;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            font-size: 20px;
            cursor: pointer;
            pointer-events: auto;
            transition: all 0.3s;
        }

        #soundToggle:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.1);
        }

        .piece-count {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.8);
            margin-top: 5px;
        }

        #tutorialOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            pointer-events: auto;
        }

        #tutorialContent {
            background: white;
            padding: 40px;
            border-radius: 20px;
            max-width: 800px;
            max-height: 90vh;
            overflow-y: auto;
        }

        .tutorial-step {
            margin: 30px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 5px solid #667eea;
        }

        .tutorial-step h3 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 20px;
        }

        .tutorial-step p {
            line-height: 1.8;
            color: #333;
            font-size: 16px;
        }

        .tutorial-highlight {
            background: #ffd700;
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: bold;
        }

        #startGameBtn {
            width: 100%;
            padding: 20px;
            font-size: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 20px;
            font-weight: bold;
        }

        #startGameBtn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.4);
        }

        .click-hint {
            position: absolute;
            pointer-events: none;
            font-size: 24px;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.2); opacity: 0.7; }
        }

        #statsPanel {
            position: absolute;
            top: 100px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            backdrop-filter: blur(10px);
            padding: 20px;
            border-radius: 15px;
            color: white;
            pointer-events: auto;
            min-width: 180px;
            transform: translateX(-220px);
            transition: transform 0.3s ease;
            z-index: 100;
        }

        #statsPanel.visible {
            transform: translateX(0);
        }

        @media (max-width: 768px) {
            #statsPanel {
                top: 80px;
                left: 10px;
                padding: 15px;
                min-width: 150px;
            }
        }

        #statsToggle {
            position: absolute;
            top: 100px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: 2px solid rgba(255, 215, 0, 0.5);
            padding: 10px 15px;
            border-radius: 10px;
            cursor: pointer;
            pointer-events: auto;
            font-size: 20px;
            transition: all 0.3s;
            z-index: 50;
            touch-action: manipulation;
        }

        #statsToggle:hover, #statsToggle:active {
            background: rgba(0, 0, 0, 0.9);
            border-color: #ffd700;
            transform: scale(1.1);
        }

        @media (max-width: 768px) {
            #statsToggle {
                top: 80px;
                left: 10px;
                padding: 8px 12px;
                font-size: 18px;
            }
        }

        .stat-item {
            margin: 10px 0;
            font-size: 16px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .stat-value {
            font-weight: bold;
            font-size: 20px;
            color: #ffd700;
        }

        #comboDisplay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
            pointer-events: none;
            display: none;
            animation: comboAnim 1s ease-out;
        }

        @keyframes comboAnim {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        #cameraToggle {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            padding: 12px 20px;
            border-radius: 10px;
            cursor: pointer;
            pointer-events: auto;
            font-size: 16px;
            transition: all 0.3s;
            font-weight: bold;
        }

        #cameraToggle:hover {
            background: rgba(0, 0, 0, 0.9);
            border-color: #667eea;
            transform: translateY(-2px);
        }

        .particle-trail {
            position: absolute;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            pointer-events: none;
        }

        #minimap {
            position: absolute;
            bottom: 100px;
            right: 20px;
            width: 120px;
            height: 120px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            pointer-events: none;
            display: block;
        }

        @media (max-width: 768px) {
            #minimap {
                width: 100px;
                height: 100px;
                bottom: 80px;
                right: 10px;
            }
        }

        #minimapCanvas {
            width: 100%;
            height: 100%;
            border-radius: 8px;
        }

        #themeToggle {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: 2px solid rgba(255, 255, 255, 0.3);
            padding: 10px 20px;
            border-radius: 10px;
            cursor: pointer;
            pointer-events: auto;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s;
        }

        #themeToggle:hover {
            background: rgba(0, 0, 0, 0.9);
            border-color: #667eea;
        }
    </style>
</head>
<body>
    <div id="gameContainer"></div>
    
    <div id="ui">
        <div id="tutorialOverlay">
            <div id="tutorialContent">
                <h2 style="color: #667eea; text-align: center; font-size: 32px; margin-bottom: 30px;">üé≤ Welcome to 3D Ludo! üé≤</h2>
                
                <div class="tutorial-step">
                    <h3>üìç Step 1: Starting the Game</h3>
                    <p>You are the <span class="tutorial-highlight">RED player</span>. Your 4 pieces start in the red corner (bottom-left). To bring a piece onto the board, you MUST roll a <span class="tutorial-highlight">6</span>!</p>
                    <p>üí° <strong>Try it:</strong> Keep rolling until you get a 6, then click on one of your red pieces to move it to the starting position.</p>
                </div>

                <div class="tutorial-step">
                    <h3>üéØ Step 2: Moving Your Pieces</h3>
                    <p>After rolling the dice, <span class="tutorial-highlight">click on any glowing red piece</span> to move it. The piece will automatically move the number of spaces shown on the dice.</p>
                    <p>üí° Your pieces move clockwise around the board toward the center home area.</p>
                </div>

                <div class="tutorial-step">
                    <h3>‚≠ê Step 3: Safe Zones</h3>
                    <p>Spaces with <span class="tutorial-highlight">golden stars</span> are safe zones. Your pieces cannot be captured here!</p>
                </div>

                <div class="tutorial-step">
                    <h3>üí• Step 4: Capturing Opponents</h3>
                    <p>If you land on a space with an opponent's piece (not in a safe zone), you <span class="tutorial-highlight">capture it!</span> The opponent's piece goes back to their starting area, and you get another turn.</p>
                </div>

                <div class="tutorial-step">
                    <h3>üé≤ Step 5: Rolling a 6</h3>
                    <p>Rolling a <span class="tutorial-highlight">6 is special</span>! You get:</p>
                    <p>‚ú® An extra turn to roll again<br>
                    ‚ú® The ability to bring out a new piece from your corner<br>
                    ‚ú® Or move an existing piece 6 spaces</p>
                </div>

                <div class="tutorial-step">
                    <h3>üè† Step 6: Getting Home</h3>
                    <p>After going around the board, your pieces enter the <span class="tutorial-highlight">red colored path</span> leading to the center. Get all 4 pieces to the golden center to win!</p>
                </div>

                <div class="tutorial-step">
                    <h3>ü§ñ Step 7: AI Opponents</h3>
                    <p>You're playing against 3 AI opponents (Green, Yellow, Blue). They'll take their turns automatically. Watch and learn their strategies!</p>
                </div>

                <button id="startGameBtn">üéÆ Start Playing! üéÆ</button>
            </div>
        </div>

        <button id="soundToggle">üîä</button>
        <button id="themeToggle">üåô Night Mode</button>
        
        <button id="statsToggle">üìä</button>
        
        <div id="statsPanel">
            <h3 style="margin: 0 0 15px 0; text-align: center; color: #ffd700;">üìä Your Stats</h3>
            <div class="stat-item">
                <span>Captures:</span>
                <span class="stat-value" id="captureCount">0</span>
            </div>
            <div class="stat-item">
                <span>Sixes:</span>
                <span class="stat-value" id="sixCount">0</span>
            </div>
            <div class="stat-item">
                <span>Combo:</span>
                <span class="stat-value" id="comboCount">0</span>
            </div>
            <div class="stat-item">
                <span>Moves:</span>
                <span class="stat-value" id="moveCount">0</span>
            </div>
        </div>

        <div id="comboDisplay"></div>
        
        <div id="topBar">
            <div class="playerInfo" id="player0Info">
                <div class="playerName">Red Player</div>
                <div class="playerPieces"></div>
            </div>
            <div class="playerInfo" id="player1Info">
                <div class="playerName">Green Player (AI)</div>
                <div class="playerPieces"></div>
            </div>
            <div class="playerInfo" id="player2Info">
                <div class="playerName">Yellow Player (AI)</div>
                <div class="playerPieces"></div>
            </div>
            <div class="playerInfo" id="player3Info">
                <div class="playerName">Blue Player (AI)</div>
                <div class="playerPieces"></div>
            </div>
        </div>

        <div id="diceDisplay">
            <canvas id="diceCanvas"></canvas>
            <div id="diceLabel">Roll the dice!</div>
        </div>

        <div id="controls">
            <button id="rulesButton">Rules</button>
            <button id="rollButton">Roll Dice</button>
            <button id="restartButton">New Game</button>
        </div>

        <button id="cameraToggle">üìπ Dynamic Camera</button>

        <div id="minimap" class="visible">
            <canvas id="minimapCanvas" width="150" height="150"></canvas>
        </div>

        <div id="message"></div>

        <div id="rulesModal">
            <h2>üé≤ Ludo Game Rules</h2>
            <ul>
                <li><strong>Objective:</strong> Move all 4 of your pieces from start to home before other players.</li>
                <li><strong>Starting:</strong> Roll a 6 to bring a piece out of the starting area.</li>
                <li><strong>Movement:</strong> Move your pieces clockwise around the board based on dice roll.</li>
                <li><strong>Capturing:</strong> Landing on an opponent's piece sends it back to start.</li>
                <li><strong>Safe Zones:</strong> Star marked spaces are safe - pieces cannot be captured there.</li>
                <li><strong>Home Stretch:</strong> After completing the circuit, pieces enter the colored home column.</li>
                <li><strong>Winning:</strong> Get all 4 pieces to the center home area to win!</li>
                <li><strong>Extra Roll:</strong> Rolling a 6 gives you another turn.</li>
                <li><strong>Strategy:</strong> Decide whether to bring out new pieces or advance existing ones!</li>
            </ul>
            <button id="closeRules">Got It!</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game Configuration
        const COLORS = [0xff4444, 0x44ff44, 0xffff44, 0x4444ff];
        const COLOR_NAMES = ['Red', 'Green', 'Yellow', 'Blue'];
        const BOARD_SIZE = 15;
        const CELL_SIZE = 1;
        
        // Game State
        let scene, camera, renderer, raycaster, mouse;
        let board = [];
        let pieces = [];
        let currentPlayer = 0;
        let diceValue = 0;
        let gameState = 'waiting'; // waiting, rolled, moving, ai_turn
        let selectedPiece = null;
        let validMoves = [];
        let diceScene, diceCamera, diceRenderer, diceMesh;
        let diceRotationX = 0, diceRotationY = 0, diceRotationZ = 0;
        let soundEnabled = true;
        let playerStats = { captures: 0, sixes: 0, moves: 0, combo: 0 };
        let glowingPieces = [];
        let cameraMode = 'dynamic'; // 'dynamic' or 'static'
        let cameraAngle = 0;
        let minimapCtx;
        let currentTheme = 'default'; // 'default' or 'night'

        // Simple sound generation using Web Audio API
        let audioContext = null;

        function initAudio() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        function playSound(type) {
            if (!soundEnabled) return;
            
            try {
                initAudio();
                
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                switch(type) {
                    case 'dice':
                        oscillator.frequency.value = 400;
                        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.1);
                        break;
                    case 'move':
                        oscillator.frequency.value = 600;
                        gainNode.gain.setValueAtTime(0.2, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.15);
                        break;
                    case 'capture':
                        oscillator.type = 'sawtooth';
                        oscillator.frequency.value = 200;
                        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.3);
                        break;
                    case 'home':
                        oscillator.type = 'sine';
                        oscillator.frequency.value = 800;
                        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.4);
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.4);
                        break;
                    case 'win':
                        // Victory fanfare
                        [523, 659, 784, 1047].forEach((freq, i) => {
                            const osc = audioContext.createOscillator();
                            const gain = audioContext.createGain();
                            osc.connect(gain);
                            gain.connect(audioContext.destination);
                            osc.frequency.value = freq;
                            gain.gain.setValueAtTime(0.2, audioContext.currentTime + i * 0.15);
                            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + i * 0.15 + 0.3);
                            osc.start(audioContext.currentTime + i * 0.15);
                            osc.stop(audioContext.currentTime + i * 0.15 + 0.3);
                        });
                        break;
                }
            } catch(e) {
                console.log('Audio not available');
            }
        }

        // Board path coordinates (standard Ludo board)
        const paths = {
            0: [ // Red path
                [6,1], [6,2], [6,3], [6,4], [6,5], [5,6], [4,6], [3,6], [2,6], [1,6], [0,6],
                [0,7], [0,8], [1,8], [2,8], [3,8], [4,8], [5,8], [6,9], [6,10], [6,11], [6,12], [6,13],
                [7,13], [8,13], [8,12], [8,11], [8,10], [8,9], [9,8], [10,8], [11,8], [12,8], [13,8], [14,8],
                [14,7], [14,6], [13,6], [12,6], [11,6], [10,6], [9,6], [8,5], [8,4], [8,3], [8,2], [8,1],
                [7,1], [7,2], [7,3], [7,4], [7,5], [7,6], [7,7] // home stretch + center
            ],
            1: [ // Green path (starts at index 13)
                [1,8], [2,8], [3,8], [4,8], [5,8], [6,9], [6,10], [6,11], [6,12], [6,13], [7,13],
                [8,13], [8,12], [8,11], [8,10], [8,9], [9,8], [10,8], [11,8], [12,8], [13,8], [14,8], [14,7],
                [14,6], [13,6], [12,6], [11,6], [10,6], [9,6], [8,5], [8,4], [8,3], [8,2], [8,1], [7,1],
                [6,1], [6,2], [6,3], [6,4], [6,5], [5,6], [4,6], [3,6], [2,6], [1,6], [0,6], [0,7],
                [1,7], [2,7], [3,7], [4,7], [5,7], [6,7], [7,7] // home stretch + center
            ],
            2: [ // Yellow path (starts at index 26)
                [8,13], [8,12], [8,11], [8,10], [8,9], [9,8], [10,8], [11,8], [12,8], [13,8], [14,8],
                [14,7], [14,6], [13,6], [12,6], [11,6], [10,6], [9,6], [8,5], [8,4], [8,3], [8,2], [8,1],
                [7,1], [6,1], [6,2], [6,3], [6,4], [6,5], [5,6], [4,6], [3,6], [2,6], [1,6], [0,6],
                [0,7], [0,8], [1,8], [2,8], [3,8], [4,8], [5,8], [6,9], [6,10], [6,11], [6,12], [6,13], [7,13],
                [7,12], [7,11], [7,10], [7,9], [7,8], [7,7] // home stretch + center
            ],
            3: [ // Blue path (starts at index 39)
                [13,6], [12,6], [11,6], [10,6], [9,6], [8,5], [8,4], [8,3], [8,2], [8,1], [7,1],
                [6,1], [6,2], [6,3], [6,4], [6,5], [5,6], [4,6], [3,6], [2,6], [1,6], [0,6], [0,7],
                [0,8], [1,8], [2,8], [3,8], [4,8], [5,8], [6,9], [6,10], [6,11], [6,12], [6,13], [7,13],
                [8,13], [8,12], [8,11], [8,10], [8,9], [9,8], [10,8], [11,8], [12,8], [13,8], [14,8], [14,7],
                [13,7], [12,7], [11,7], [10,7], [9,7], [8,7], [7,7] // home stretch + center
            ]
        };

        // Safe positions (star marks)
        const safePositions = [
            [6,2], [2,6], [1,8], [6,12], [8,13], [12,8], [13,6], [8,1]
        ];

        // Starting positions
        const startPositions = {
            0: [[1,1], [1,4], [4,1], [4,4]], // Red
            1: [[1,10], [1,13], [4,10], [4,13]], // Green
            2: [[10,10], [10,13], [13,10], [13,13]], // Yellow
            3: [[10,1], [10,4], [13,1], [13,4]] // Blue
        };

        // Initialize Three.js
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x1a1a2e);
            scene.fog = new THREE.Fog(0x1a1a2e, 30, 60);

            // Camera
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(12, 20, 12);
            camera.lookAt(7, 0, 7);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('gameContainer').appendChild(renderer.domElement);

            // Raycaster for mouse interaction
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);

            const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
            mainLight.position.set(10, 20, 10);
            mainLight.castShadow = true;
            mainLight.shadow.camera.left = -20;
            mainLight.shadow.camera.right = 20;
            mainLight.shadow.camera.top = 20;
            mainLight.shadow.camera.bottom = -20;
            mainLight.shadow.mapSize.width = 2048;
            mainLight.shadow.mapSize.height = 2048;
            scene.add(mainLight);

            const fillLight = new THREE.DirectionalLight(0x7b68ee, 0.3);
            fillLight.position.set(-10, 10, -10);
            scene.add(fillLight);

            // Create board
            createBoard();
            createPieces();
            createDice();
            initMinimap();
            updatePlayerInfo();

            // Event listeners
            window.addEventListener('resize', onWindowResize);
            renderer.domElement.addEventListener('click', onMouseClick);
            renderer.domElement.addEventListener('touchstart', onTouchStart);
            renderer.domElement.addEventListener('mousemove', onMouseMove);
            document.getElementById('rollButton').addEventListener('click', rollDice);
            document.getElementById('rollButton').addEventListener('touchstart', (e) => {
                e.preventDefault();
                rollDice();
            });
            document.getElementById('rulesButton').addEventListener('click', showRules);
            document.getElementById('closeRules').addEventListener('click', hideRules);
            document.getElementById('restartButton').addEventListener('click', restartGame);
            document.getElementById('soundToggle').addEventListener('click', toggleSound);
            document.getElementById('startGameBtn').addEventListener('click', startGame);
            document.getElementById('statsToggle').addEventListener('click', toggleStats);
            document.getElementById('cameraToggle').addEventListener('click', toggleCamera);
            document.getElementById('themeToggle').addEventListener('click', toggleTheme);

            // Animation loop
            animate();
            animateDice();
            updateMinimap();
        }

        function initMinimap() {
            try {
                const canvas = document.getElementById('minimapCanvas');
                if (canvas) {
                    // Set proper canvas resolution
                    canvas.width = 120;
                    canvas.height = 120;
                    minimapCtx = canvas.getContext('2d');
                }
            } catch(e) {
                console.log('Minimap initialization skipped');
            }
        }

        function updateMinimap() {
            if (!minimapCtx) return;
            
            try {
                requestAnimationFrame(updateMinimap);
                
                const ctx = minimapCtx;
                const size = 120;
                
                // Clear
                ctx.clearRect(0, 0, size, size);
                
                // Draw board outline
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.strokeRect(2, 2, size - 4, size - 4);
                
                // Draw quadrants
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.strokeRect(2, 2, size/2 - 2, size/2 - 2); // Red
                ctx.strokeRect(2, size/2, size/2 - 2, size/2 - 2); // Green
                ctx.strokeRect(size/2, size/2, size/2 - 2, size/2 - 2); // Yellow
                ctx.strokeRect(size/2, 2, size/2 - 2, size/2 - 2); // Blue
                
                // Draw pieces
                for (let p = 0; p < 4; p++) {
                    if (!pieces[p]) continue;
                    pieces[p].forEach(piece => {
                        if (piece.userData.isHome) return;
                        
                        const x = (piece.position.x / 14) * size;
                        const z = (piece.position.z / 14) * size;
                        
                        ctx.beginPath();
                        ctx.arc(x, z, 4, 0, Math.PI * 2);
                        ctx.fillStyle = `#${COLORS[p].toString(16).padStart(6, '0')}`;
                        ctx.fill();
                        
                        // Highlight current player
                        if (p === currentPlayer) {
                            ctx.strokeStyle = '#ffd700';
                            ctx.lineWidth = 2;
                            ctx.stroke();
                        }
                    });
                }
            } catch(e) {
                // Silently fail minimap updates
            }
        }

        function createDice() {
            // Setup dice canvas and renderer
            const canvas = document.getElementById('diceCanvas');
            diceScene = new THREE.Scene();
            diceCamera = new THREE.PerspectiveCamera(50, 1, 0.1, 1000);
            diceCamera.position.z = 4;

            diceRenderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
            diceRenderer.setSize(150, 150);
            diceRenderer.shadowMap.enabled = true;

            // Lighting for dice
            const ambLight = new THREE.AmbientLight(0xffffff, 0.6);
            diceScene.add(ambLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(5, 5, 5);
            dirLight.castShadow = true;
            diceScene.add(dirLight);

            // Create dice with dots
            const diceGeometry = new THREE.BoxGeometry(1.5, 1.5, 1.5);
            const diceMaterials = [];

            // Create materials for each face (1-6)
            for (let i = 1; i <= 6; i++) {
                const canvas2d = document.createElement('canvas');
                canvas2d.width = 128;
                canvas2d.height = 128;
                const ctx = canvas2d.getContext('2d');

                // White background
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, 128, 128);

                // Black border
                ctx.strokeStyle = '#333333';
                ctx.lineWidth = 4;
                ctx.strokeRect(2, 2, 124, 124);

                // Draw dots
                ctx.fillStyle = '#000000';
                const dotRadius = 8;
                const positions = getDotPositions(i);
                positions.forEach(pos => {
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, dotRadius, 0, Math.PI * 2);
                    ctx.fill();
                });

                const texture = new THREE.CanvasTexture(canvas2d);
                diceMaterials.push(new THREE.MeshStandardMaterial({ map: texture }));
            }

            diceMesh = new THREE.Mesh(diceGeometry, diceMaterials);
            diceMesh.castShadow = true;
            diceScene.add(diceMesh);

            // Add rounded edges effect
            const edges = new THREE.EdgesGeometry(diceGeometry, 15);
            const lineMaterial = new THREE.LineBasicMaterial({ color: 0xcccccc });
            const wireframe = new THREE.LineSegments(edges, lineMaterial);
            diceMesh.add(wireframe);
        }

        function getDotPositions(number) {
            const positions = [];
            const center = 64;
            const offset = 35;

            switch(number) {
                case 1:
                    positions.push({x: center, y: center});
                    break;
                case 2:
                    positions.push({x: center - offset, y: center - offset});
                    positions.push({x: center + offset, y: center + offset});
                    break;
                case 3:
                    positions.push({x: center - offset, y: center - offset});
                    positions.push({x: center, y: center});
                    positions.push({x: center + offset, y: center + offset});
                    break;
                case 4:
                    positions.push({x: center - offset, y: center - offset});
                    positions.push({x: center + offset, y: center - offset});
                    positions.push({x: center - offset, y: center + offset});
                    positions.push({x: center + offset, y: center + offset});
                    break;
                case 5:
                    positions.push({x: center - offset, y: center - offset});
                    positions.push({x: center + offset, y: center - offset});
                    positions.push({x: center, y: center});
                    positions.push({x: center - offset, y: center + offset});
                    positions.push({x: center + offset, y: center + offset});
                    break;
                case 6:
                    positions.push({x: center - offset, y: center - offset});
                    positions.push({x: center + offset, y: center - offset});
                    positions.push({x: center - offset, y: center});
                    positions.push({x: center + offset, y: center});
                    positions.push({x: center - offset, y: center + offset});
                    positions.push({x: center + offset, y: center + offset});
                    break;
            }
            return positions;
        }

        function animateDice() {
            requestAnimationFrame(animateDice);

            diceMesh.rotation.x = diceRotationX;
            diceMesh.rotation.y = diceRotationY;
            diceMesh.rotation.z = diceRotationZ;

            diceRenderer.render(diceScene, diceCamera);
        }

        function createBoard() {
            // Base platform
            const baseGeometry = new THREE.BoxGeometry(BOARD_SIZE * CELL_SIZE + 2, 0.5, BOARD_SIZE * CELL_SIZE + 2);
            const baseMaterial = new THREE.MeshStandardMaterial({ color: 0x2c3e50 });
            const base = new THREE.Mesh(baseGeometry, baseMaterial);
            base.position.set(7, -0.25, 7);
            base.receiveShadow = true;
            scene.add(base);

            // Create cells
            for (let x = 0; x < BOARD_SIZE; x++) {
                board[x] = [];
                for (let z = 0; z < BOARD_SIZE; z++) {
                    const color = getCellColor(x, z);
                    const geometry = new THREE.BoxGeometry(CELL_SIZE * 0.95, 0.1, CELL_SIZE * 0.95);
                    const material = new THREE.MeshStandardMaterial({ color });
                    const cell = new THREE.Mesh(geometry, material);
                    cell.position.set(x * CELL_SIZE, 0, z * CELL_SIZE);
                    cell.receiveShadow = true;
                    cell.userData = { x, z, type: 'cell' };
                    scene.add(cell);
                    board[x][z] = cell;

                    // Add star markers for safe zones
                    if (isSafePosition(x, z)) {
                        const starGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.15, 5);
                        const starMaterial = new THREE.MeshStandardMaterial({ color: 0xffd700, emissive: 0xffd700, emissiveIntensity: 0.5 });
                        const star = new THREE.Mesh(starGeometry, starMaterial);
                        star.position.set(x * CELL_SIZE, 0.2, z * CELL_SIZE);
                        star.rotation.x = Math.PI / 2;
                        scene.add(star);
                    }
                }
            }

            // Center home area
            const homeGeometry = new THREE.CylinderGeometry(0.8, 0.8, 0.3, 32);
            const homeMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xffd700,
                emissive: 0xffd700,
                emissiveIntensity: 0.3,
                metalness: 0.8,
                roughness: 0.2
            });
            const home = new THREE.Mesh(homeGeometry, homeMaterial);
            home.position.set(7, 0.15, 7);
            home.castShadow = true;
            scene.add(home);
        }

        function getCellColor(x, z) {
            // Red home area
            if (x >= 0 && x <= 5 && z >= 0 && z <= 5) return 0xff6b6b;
            // Green home area
            if (x >= 0 && x <= 5 && z >= 9 && z <= 14) return 0x6bff6b;
            // Yellow home area
            if (x >= 9 && x <= 14 && z >= 9 && z <= 14) return 0xffff6b;
            // Blue home area
            if (x >= 9 && x <= 14 && z >= 0 && z <= 5) return 0x6b6bff;
            
            // Path cells
            if (x === 7 || z === 7) return 0xe8e8e8;
            if ((x === 6 || x === 8) && (z >= 1 && z <= 13)) return 0xf0f0f0;
            if ((z === 6 || z === 8) && (x >= 1 && x <= 13)) return 0xf0f0f0;
            
            return 0xcccccc;
        }

        function isSafePosition(x, z) {
            return safePositions.some(pos => pos[0] === x && pos[1] === z);
        }

        function createPieces() {
            for (let player = 0; player < 4; player++) {
                pieces[player] = [];
                for (let i = 0; i < 4; i++) {
                    const geometry = new THREE.SphereGeometry(0.3, 32, 32);
                    const material = new THREE.MeshStandardMaterial({
                        color: COLORS[player],
                        metalness: 0.3,
                        roughness: 0.4
                    });
                    const piece = new THREE.Mesh(geometry, material);
                    
                    const pos = startPositions[player][i];
                    piece.position.set(pos[0] * CELL_SIZE, 0.4, pos[1] * CELL_SIZE);
                    piece.castShadow = true;
                    piece.userData = {
                        player,
                        index: i,
                        pathPosition: -1, // -1 means in starting area
                        isHome: false,
                        type: 'piece'
                    };
                    
                    scene.add(piece);
                    pieces[player][i] = piece;
                }
            }
        }

        function updatePlayerInfo() {
            for (let i = 0; i < 4; i++) {
                const info = document.getElementById(`player${i}Info`);
                info.classList.toggle('active', i === currentPlayer);
                
                const piecesDiv = info.querySelector('.playerPieces');
                piecesDiv.innerHTML = '';
                
                let inHome = 0;
                let onBoard = 0;
                pieces[i].forEach(piece => {
                    const indicator = document.createElement('div');
                    indicator.className = 'pieceIndicator';
                    if (piece.userData.isHome) {
                        indicator.style.backgroundColor = '#ffd700';
                        inHome++;
                    } else if (piece.userData.pathPosition === -1) {
                        indicator.style.backgroundColor = '#666';
                    } else {
                        indicator.style.backgroundColor = `#${COLORS[i].toString(16).padStart(6, '0')}`;
                        onBoard++;
                    }
                    piecesDiv.appendChild(indicator);
                });

                // Add piece count
                const countDiv = document.createElement('div');
                countDiv.className = 'piece-count';
                countDiv.textContent = `üè†${inHome} üéØ${onBoard}`;
                piecesDiv.appendChild(countDiv);

                if (inHome === 4) {
                    playSound('win');
                    showMessage(`üéâ ${COLOR_NAMES[i]} Player Wins! üéâ`, true);
                }
            }
        }

        function rollDice() {
            if (gameState !== 'waiting') return;
            
            playSound('dice');
            gameState = 'rolling';
            document.getElementById('rollButton').disabled = true;
            document.getElementById('diceLabel').textContent = 'Rolling...';
            
            // Animate dice roll with 3D rotation
            let rolls = 0;
            const maxRolls = 20;
            const rollInterval = setInterval(() => {
                diceValue = Math.floor(Math.random() * 6) + 1;
                
                // Random rotation during roll
                diceRotationX += 0.3 + Math.random() * 0.2;
                diceRotationY += 0.3 + Math.random() * 0.2;
                diceRotationZ += 0.2 + Math.random() * 0.2;
                
                rolls++;
                
                if (rolls >= maxRolls) {
                    clearInterval(rollInterval);
                    
                    // Set final rotation to show correct face
                    setDiceFace(diceValue);
                    
                    // Check if player needs a 6 to start
                    if (currentPlayer === 0) {
                        const allPiecesHome = pieces[0].every(p => p.userData.pathPosition === -1);
                        if (allPiecesHome && diceValue !== 6) {
                            document.getElementById('diceLabel').textContent = `Rolled ${diceValue} - Need a 6!`;
                        } else {
                            document.getElementById('diceLabel').textContent = `You rolled: ${diceValue}`;
                        }
                    } else {
                        document.getElementById('diceLabel').textContent = `${COLOR_NAMES[currentPlayer]} rolled: ${diceValue}`;
                    }
                    
                    gameState = 'rolled';
                    checkValidMoves();
                }
            }, 80);
        }

        function setDiceFace(value) {
            // Set rotation to show the correct face on top
            const rotations = {
                1: { x: 0, y: 0, z: 0 },
                2: { x: 0, y: Math.PI / 2, z: 0 },
                3: { x: 0, y: 0, z: -Math.PI / 2 },
                4: { x: 0, y: 0, z: Math.PI / 2 },
                5: { x: 0, y: -Math.PI / 2, z: 0 },
                6: { x: Math.PI, y: 0, z: 0 }
            };

            const target = rotations[value];
            const steps = 10;
            let step = 0;

            const smoothRotate = setInterval(() => {
                step++;
                const progress = step / steps;
                
                diceRotationX += (target.x - diceRotationX) * 0.3;
                diceRotationY += (target.y - diceRotationY) * 0.3;
                diceRotationZ += (target.z - diceRotationZ) * 0.3;

                if (step >= steps) {
                    clearInterval(smoothRotate);
                    diceRotationX = target.x;
                    diceRotationY = target.y;
                    diceRotationZ = target.z;
                }
            }, 50);
        }

        function checkValidMoves() {
            validMoves = [];
            const playerPieces = pieces[currentPlayer];
            
            playerPieces.forEach((piece, idx) => {
                if (piece.userData.isHome) return;
                
                if (piece.userData.pathPosition === -1 && diceValue === 6) {
                    validMoves.push(idx);
                } else if (piece.userData.pathPosition >= 0) {
                    const newPos = piece.userData.pathPosition + diceValue;
                    if (newPos < paths[currentPlayer].length) {
                        validMoves.push(idx);
                    }
                }
            });

            // Track sixes for player
            if (currentPlayer === 0 && diceValue === 6) {
                playerStats.sixes++;
                playerStats.combo++;
                updateStats();
                showCombo();
            }

            if (validMoves.length === 0) {
                showMessage('No valid moves! Next player...');
                if (currentPlayer === 0) playerStats.combo = 0;
                updateStats();
                setTimeout(nextTurn, 1500);
            } else if (currentPlayer !== 0) {
                // AI move
                setTimeout(makeAIMove, 1000);
            } else {
                highlightValidPieces();
                showMessage(`Click a glowing red piece to move it ${diceValue} spaces!`);
            }
        }

        function updateStats() {
            try {
                const captureEl = document.getElementById('captureCount');
                const sixEl = document.getElementById('sixCount');
                const comboEl = document.getElementById('comboCount');
                const moveEl = document.getElementById('moveCount');
                
                if (captureEl) captureEl.textContent = playerStats.captures;
                if (sixEl) sixEl.textContent = playerStats.sixes;
                if (comboEl) comboEl.textContent = playerStats.combo;
                if (moveEl) moveEl.textContent = playerStats.moves;
            } catch(e) {
                console.log('Stats update skipped');
            }
        }

        function showCombo() {
            if (playerStats.combo < 2) return;
            
            try {
                const comboDisplay = document.getElementById('comboDisplay');
                if (!comboDisplay) return;
                
                comboDisplay.textContent = `${playerStats.combo}x COMBO! üî•`;
                comboDisplay.style.display = 'block';
                
                setTimeout(() => {
                    comboDisplay.style.display = 'none';
                }, 2000);
            } catch(e) {
                console.log('Combo display skipped');
            }
        }

        function highlightValidPieces() {
            // Clear previous glowing pieces
            glowingPieces.forEach(piece => {
                if (piece.userData.glowRing) {
                    piece.userData.glowRing.material.opacity = 0;
                    piece.userData.glowRing.scale.set(1, 1, 1);
                }
                piece.scale.set(1, 1, 1);
            });
            glowingPieces = [];

            pieces[currentPlayer].forEach((piece, idx) => {
                if (validMoves.includes(idx)) {
                    glowingPieces.push(piece);
                    
                    // Animate glow ring
                    const ring = piece.userData.glowRing;
                    if (ring) {
                        ring.material.opacity = 0.8; // Start visible
                        ring.scale.set(1, 1, 1);
                        
                        let pulseUp = true;
                        let animationActive = true;
                        
                        const pulseAnimation = () => {
                            if (!animationActive || gameState !== 'rolled' || !validMoves.includes(idx)) {
                                if (ring) {
                                    ring.material.opacity = 0;
                                    ring.scale.set(1, 1, 1);
                                }
                                return;
                            }
                            
                            if (pulseUp) {
                                ring.material.opacity += 0.03;
                                ring.scale.x += 0.015;
                                ring.scale.y += 0.015;
                                ring.scale.z += 0.015;
                                if (ring.material.opacity >= 1.0) pulseUp = false;
                            } else {
                                ring.material.opacity -= 0.03;
                                ring.scale.x -= 0.015;
                                ring.scale.y -= 0.015;
                                ring.scale.z -= 0.015;
                                if (ring.material.opacity <= 0.5) pulseUp = true;
                            }
                            
                            requestAnimationFrame(pulseAnimation);
                        };
                        
                        piece.userData.stopAnimation = () => { animationActive = false; };
                        pulseAnimation();
                    }
                }
            });
        }

        function makeAIMove() {
            // AI logic: prioritize capturing, then moving pieces forward
            let bestMove = validMoves[0];
            let bestScore = -1;

            validMoves.forEach(pieceIdx => {
                const piece = pieces[currentPlayer][pieceIdx];
                let score = 0;

                if (piece.userData.pathPosition === -1) {
                    score = 50; // Bringing out pieces is good
                } else {
                    const newPos = piece.userData.pathPosition + diceValue;
                    if (newPos >= paths[currentPlayer].length - 1) {
                        score = 100; // Reaching home is best
                    } else {
                        score = newPos; // Moving forward is good
                        
                        // Check if we can capture
                        const targetCell = paths[currentPlayer][newPos];
                        for (let p = 0; p < 4; p++) {
                            if (p === currentPlayer) continue;
                            pieces[p].forEach(enemyPiece => {
                                if (!enemyPiece.userData.isHome && enemyPiece.userData.pathPosition >= 0) {
                                    const enemyCell = paths[p][enemyPiece.userData.pathPosition];
                                    if (enemyCell[0] === targetCell[0] && enemyCell[1] === targetCell[1]) {
                                        if (!isSafePosition(targetCell[0], targetCell[1])) {
                                            score += 30; // Capturing is valuable
                                        }
                                    }
                                }
                            });
                        }
                    }
                }

                if (score > bestScore) {
                    bestScore = score;
                    bestMove = pieceIdx;
                }
            });

            movePiece(pieces[currentPlayer][bestMove]);
        }

        function movePiece(piece) {
            if (!piece) return;

            gameState = 'moving';
            const startPos = piece.userData.pathPosition;
            const targetPos = startPos === -1 ? 0 : startPos + diceValue;
            
            // Track moves for player
            if (currentPlayer === 0) {
                playerStats.moves++;
                updateStats();
            }
            
            if (targetPos >= paths[currentPlayer].length - 1) {
                // Piece reaches home
                animatePieceMovement(piece, targetPos, () => {
                    piece.userData.isHome = true;
                    piece.userData.pathPosition = paths[currentPlayer].length - 1;
                    playSound('home');
                    updatePlayerInfo();
                    
                    if (pieces[currentPlayer].every(p => p.userData.isHome)) {
                        return; // Winner already announced in updatePlayerInfo
                    }
                    
                    if (diceValue === 6) {
                        showMessage('Piece home! Roll again!');
                        setTimeout(() => {
                            gameState = 'waiting';
                            document.getElementById('rollButton').disabled = false;
                        }, 1000);
                    } else {
                        if (currentPlayer === 0) playerStats.combo = 0;
                        updateStats();
                        nextTurn();
                    }
                });
            } else {
                const captured = checkCapture(targetPos);
                animatePieceMovement(piece, targetPos, () => {
                    piece.userData.pathPosition = targetPos;
                    playSound('move');
                    
                    if (captured) {
                        if (currentPlayer === 0) {
                            playerStats.captures++;
                            playerStats.combo++;
                            updateStats();
                            showCombo();
                        }
                        showMessage('Captured! Roll again!');
                        setTimeout(() => {
                            gameState = 'waiting';
                            document.getElementById('rollButton').disabled = false;
                        }, 1000);
                    } else if (diceValue === 6) {
                        showMessage('Six! Roll again!');
                        setTimeout(() => {
                            gameState = 'waiting';
                            document.getElementById('rollButton').disabled = false;
                        }, 1000);
                    } else {
                        if (currentPlayer === 0) playerStats.combo = 0;
                        updateStats();
                        nextTurn();
                    }
                });
            }
        }

        function checkCapture(targetPos) {
            const targetCell = paths[currentPlayer][targetPos];
            if (isSafePosition(targetCell[0], targetCell[1])) return false;

            let captured = false;
            for (let p = 0; p < 4; p++) {
                if (p === currentPlayer) continue;
                pieces[p].forEach((enemyPiece, idx) => {
                    if (!enemyPiece.userData.isHome && enemyPiece.userData.pathPosition >= 0) {
                        const enemyCell = paths[p][enemyPiece.userData.pathPosition];
                        if (enemyCell[0] === targetCell[0] && enemyCell[1] === targetCell[1]) {
                            // Capture!
                            const startPos = startPositions[p][idx];
                            enemyPiece.position.set(startPos[0] * CELL_SIZE, 0.4, startPos[1] * CELL_SIZE);
                            enemyPiece.userData.pathPosition = -1;
                            captured = true;
                            playSound('capture');
                            createCaptureEffect(targetCell[0] * CELL_SIZE, targetCell[1] * CELL_SIZE);
                        }
                    }
                });
            }
            return captured;
        }

        function animatePieceMovement(piece, targetPos, callback) {
            const path = paths[currentPlayer];
            const startPos = piece.userData.pathPosition === -1 ? 0 : piece.userData.pathPosition;
            const steps = [];
            
            for (let i = startPos; i <= targetPos; i++) {
                steps.push(path[i]);
            }

            let stepIndex = 0;
            const moveInterval = setInterval(() => {
                if (stepIndex >= steps.length) {
                    clearInterval(moveInterval);
                    callback();
                    return;
                }

                const target = steps[stepIndex];
                piece.position.x = target[0] * CELL_SIZE;
                piece.position.z = target[1] * CELL_SIZE;
                piece.position.y = 0.7;
                
                // Create trail effect
                createTrailParticle(piece.position.x, piece.position.z, COLORS[currentPlayer]);
                
                setTimeout(() => {
                    piece.position.y = 0.4;
                }, 100);

                stepIndex++;
            }, 200);
        }

        function createTrailParticle(x, z, color) {
            const geometry = new THREE.SphereGeometry(0.1, 8, 8);
            const material = new THREE.MeshBasicMaterial({ 
                color: color,
                transparent: true,
                opacity: 0.6
            });
            const particle = new THREE.Mesh(geometry, material);
            particle.position.set(x, 0.3, z);
            scene.add(particle);

            let life = 1.0;
            const fadeOut = () => {
                life -= 0.05;
                particle.material.opacity = life * 0.6;
                particle.scale.set(1 - (1 - life) * 0.5, 1 - (1 - life) * 0.5, 1 - (1 - life) * 0.5);
                
                if (life > 0) {
                    requestAnimationFrame(fadeOut);
                } else {
                    scene.remove(particle);
                    geometry.dispose();
                    material.dispose();
                }
            };
            fadeOut();
        }

        function createCaptureEffect(x, z) {
            const particleCount = 20;
            for (let i = 0; i < particleCount; i++) {
                const geometry = new THREE.SphereGeometry(0.1, 8, 8);
                const material = new THREE.MeshBasicMaterial({ color: 0xff0000 });
                const particle = new THREE.Mesh(geometry, material);
                particle.position.set(x, 0.5, z);
                
                const velocity = {
                    x: (Math.random() - 0.5) * 0.2,
                    y: Math.random() * 0.3,
                    z: (Math.random() - 0.5) * 0.2
                };
                
                scene.add(particle);
                
                const animate = () => {
                    particle.position.x += velocity.x;
                    particle.position.y += velocity.y;
                    particle.position.z += velocity.z;
                    velocity.y -= 0.01;
                    particle.material.opacity -= 0.02;
                    
                    if (particle.material.opacity > 0) {
                        requestAnimationFrame(animate);
                    } else {
                        scene.remove(particle);
                    }
                };
                
                particle.material.transparent = true;
                animate();
            }
        }

        function nextTurn() {
            // Clear highlights and glow rings
            glowingPieces.forEach(piece => {
                if (piece.userData.stopAnimation) {
                    piece.userData.stopAnimation();
                }
                if (piece.userData.glowRing) {
                    piece.userData.glowRing.material.opacity = 0;
                    piece.userData.glowRing.scale.set(1, 1, 1);
                }
            });
            glowingPieces = [];

            currentPlayer = (currentPlayer + 1) % 4;
            updatePlayerInfo();
            gameState = 'waiting';
            
            if (currentPlayer === 0) {
                document.getElementById('rollButton').disabled = false;
            } else {
                setTimeout(rollDice, 500);
            }
        }

        function showMessage(text, isWinner = false) {
            const msg = document.getElementById('message');
            msg.textContent = text;
            msg.className = isWinner ? 'winner-message' : '';
            msg.style.display = 'block';
            
            if (!isWinner) {
                setTimeout(() => {
                    msg.style.display = 'none';
                }, 2000);
            }
        }

        function showRules() {
            document.getElementById('rulesModal').style.display = 'block';
        }

        function hideRules() {
            document.getElementById('rulesModal').style.display = 'none';
        }

        function restartGame() {
            location.reload();
        }

        function toggleSound() {
            soundEnabled = !soundEnabled;
            const btn = document.getElementById('soundToggle');
            if (btn) btn.textContent = soundEnabled ? 'üîä' : 'üîá';
        }

        function toggleStats() {
            const panel = document.getElementById('statsPanel');
            if (panel) panel.classList.toggle('visible');
        }

        function startGame() {
            const overlay = document.getElementById('tutorialOverlay');
            if (overlay) overlay.style.display = 'none';
            initAudio(); // Initialize audio on user interaction
            showMessage('Roll a 6 to start! Click "Roll Dice"', false);
        }

        function showClickHint(element) {
            if (!element) return;
            
            const hint = document.createElement('div');
            hint.className = 'click-hint';
            hint.textContent = 'üëÜ';
            hint.style.left = element.offsetLeft + element.offsetWidth / 2 + 'px';
            hint.style.top = element.offsetTop - 40 + 'px';
            document.body.appendChild(hint);
            
            setTimeout(() => {
                hint.remove();
            }, 2000);
        }

        function onMouseClick(event) {
            if (gameState !== 'rolled' || currentPlayer !== 0) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children);

            for (let intersect of intersects) {
                if (intersect.object.userData.type === 'piece' && 
                    intersect.object.userData.player === currentPlayer &&
                    validMoves.includes(intersect.object.userData.index)) {
                    movePiece(intersect.object);
                    break;
                }
            }
        }

        function onTouchStart(event) {
            if (gameState !== 'rolled' || currentPlayer !== 0) return;
            
            event.preventDefault();
            const touch = event.touches[0];
            
            mouse.x = (touch.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(touch.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children);

            for (let intersect of intersects) {
                if (intersect.object.userData.type === 'piece' && 
                    intersect.object.userData.player === currentPlayer &&
                    validMoves.includes(intersect.object.userData.index)) {
                    movePiece(intersect.object);
                    break;
                }
            }
        }

        function onMouseMove(event) {
            if (currentPlayer !== 0 || gameState !== 'rolled') return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);

            let hovering = false;
            pieces[currentPlayer].forEach((piece, idx) => {
                if (validMoves.includes(idx)) {
                    const isHovered = intersects.some(intersect => intersect.object === piece);
                    if (isHovered) {
                        piece.position.y = 0.6;
                        hovering = true;
                    } else {
                        piece.position.y = 0.4;
                    }
                }
            });

            renderer.domElement.style.cursor = hovering ? 'pointer' : 'default';
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // Camera movement based on mode
            if (cameraMode === 'dynamic') {
                const time = Date.now() * 0.0001;
                camera.position.x = 12 + Math.sin(time) * 2;
                camera.position.z = 12 + Math.cos(time) * 2;
                camera.lookAt(7, 0, 7);
            } else {
                // Follow current player
                const playerPositions = [
                    { x: 5, z: 5 },   // Red
                    { x: 5, z: 9 },   // Green
                    { x: 9, z: 9 },   // Yellow
                    { x: 9, z: 5 }    // Blue
                ];
                const target = playerPositions[currentPlayer];
                camera.position.x += (target.x + 5 - camera.position.x) * 0.02;
                camera.position.z += (target.z + 5 - camera.position.z) * 0.02;
                camera.lookAt(7, 0, 7);
            }
            
            renderer.render(scene, camera);
        }

        function toggleCamera() {
            cameraMode = cameraMode === 'dynamic' ? 'player' : 'dynamic';
            const btn = document.getElementById('cameraToggle');
            if (btn) btn.textContent = cameraMode === 'dynamic' ? 'üìπ Dynamic Camera' : 'üìπ Player Focus';
        }

        function toggleTheme() {
            currentTheme = currentTheme === 'default' ? 'night' : 'default';
            const btn = document.getElementById('themeToggle');
            
            if (currentTheme === 'night') {
                scene.background = new THREE.Color(0x0a0a1a);
                scene.fog = new THREE.Fog(0x0a0a1a, 30, 60);
                if (btn) btn.textContent = '‚òÄÔ∏è Day Mode';
                document.body.style.background = 'linear-gradient(135deg, #1a1a2e 0%, #16213e 100%)';
            } else {
                scene.background = new THREE.Color(0x1a1a2e);
                scene.fog = new THREE.Fog(0x1a1a2e, 30, 60);
                if (btn) btn.textContent = 'üåô Night Mode';
                document.body.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
            }
        }

        // Start the game
        init();
    </script>
</body>
</html>